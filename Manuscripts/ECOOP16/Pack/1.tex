\title{Formal Language Recognition with the Java Type Checker}
\documentclass[a4paper,USenglish]{lipics-v2016}

\input 00.sty
\bibliographystyle{plainurl}

\author[1]{Yossi Gil}
\author[1]{Tomer Levy}
\affil[1]{Department of Computer Science, The Technion---Israel Institute of Technology, Haifa, Israel.}

\def\ReplaceInThesis#1#2{#1}

\begin{filecontents}{00.listing}
String time(int hours, int minutes, int seconds) {¢¢
    return new StringBuilder()
      ¢¢.append(hours).append(':')
      ¢¢.append(minutes).append(':')
      ¢¢.append(seconds)
      ¢¢.toString();
}
\end{filecontents}
\begin{filecontents}{1.listing}
String time(int hours, int minutes, int seconds) {¢¢
    return new StringBuilder()
      ¢¢.append(hours).append(':')
      ¢¢.append(minutes).append(':')
      ¢¢.append(seconds)
      ¢¢.toString();
}
\end{filecontents}
\begin{filecontents}{2.listing}
String time(int hours, int minutes, int seconds) {¢¢
    return new StringBuilder()
      ¢¢.append(hours).append(':')
      ¢¢.append(minutes).append(':')
      ¢¢.append(seconds)
      ¢¢.toString();
}
\end{filecontents}
\begin{filecontents}{abc.listing}

\end{filecontents}
\begin{filecontents}{binary-function-example.listing}
public static void four_use_cases_of_function_f() {
  ¢$γ$¢1 _1 = f.r1().s1(); // ✓ ¢$f(r_1,s_1) = \gamma_1$¢
  ¢$γ$¢2 _2 = f.r1().s2(); // ✓ ¢$f(r_1,s_2) = \gamma_2$¢
  ¢$γ$¢2 _3 = f.r2().s1(); // ✓ ¢$f(r_2,s_1) = \gamma_2$¢
  f.r2().s2().g(); // ✗ method ¢\cc{s2()}¢ undefined in type ¢\cc{\scriptsize $\Gamma$'}¢
}
\end{filecontents}
\begin{filecontents}{binary-function.listing}
public static abstract class f { // Starting point of fluent API
  public static r1 r1() { return null; }
  public static r2 r2() { return null; }
}  
public static abstract class R { 
  public abstract ¢$Γ$¢¢$ʹ$¢ s1();
  public abstract ¢$Γ$¢¢$ʹ$¢ s2();
  public static final class r1 extends R {
    @Override public ¢$γ$¢1 s1() { return null; } 
    @Override public ¢$γ$¢2 s2() { return null; }
  }
  public static final class r2 extends R {
    @Override public ¢$γ$¢2 s1() { return null; }
    @Override public ¢$Γ$¢¢$ʹ$¢.¤ s2() { return null; }
  }
}
\end{filecontents}
\begin{filecontents}{compiler.listing}
static interface Cons<Car,Cdr>{ 
  Cons<
    Cons<Car,Cdr>,
    Cons<Car,Cdr>
  > d(); 
}
\end{filecontents}
\begin{filecontents}{gamma-example.listing}
public static void five_use_cases_of_function_g() {
  ¢$γ$¢2 _1 = new ¢$γ$¢1().g(); // ✓
  ¢$γ$¢1 _2 = new ¢$γ$¢2().g(); // ✗ type mismatch
  ¢$Γ$¢¢$ʹ$¢.¤ _3 = new ¢$γ$¢2().g(); // ✗ class ¤ is private
  ¢$Γ$¢¢$ʹ$¢ _4 = new ¢$γ$¢2().g(); // ✓
  _4.g(); // ✗ g() undefined in type ¢$Γ$¢¢$ʹ$¢
}
\end{filecontents}
\begin{filecontents}{gamma.listing}
public static abstract class ¢$Γ$¢¢$ʹ$¢ { 
  private static abstract class ¤ extends ¢$Γ$¢¢$ʹ$¢ {
    // Empty private class, cannot be used by clients.
    private ¤() { /* Private constructor hinders extension by clients */ }
  }
  public  static abstract class ¢$Γ$¢ extends ¢$Γ$¢¢$ʹ$¢ { 
    public abstract ¢$Γ$¢¢$ʹ$¢ g(); 
    public static final class ¢$γ$¢1 extends ¢$Γ$¢ {
      // Covariant return type in overriding:
      @Override public ¢$γ$¢2 g() { return null; } 
    }
    public static final class ¢$γ$¢2 extends ¢$Γ$¢ {
      // Covariant return type in overriding:
      @Override  public ¢$Γ$¢¢$ʹ$¢.¤ g() { return null; }
    }
  }
} 
\end{filecontents}
\begin{filecontents}{id.listing}
interface ID<T extends ID<?>> {
  default T id() { return null; }
}
class A implements ID<A> { /**/ }
abstract class B<Z extends B<?>> implements ID<Z> { /**/ }
class C extends B<C> { /**/ }
\end{filecontents}
\begin{filecontents}{jump-stack-currency.listing}
interface ¤ extends JS<¤, ¤, ¤> {
  @Override public ¢$Γ$¢¢$ʹ$¢.¤ top();
  @Override public ¤ pop();
  @Override public ¤ ¢$γ$¢1();
  @Override public ¤ ¢$γ$¢2();
}
\end{filecontents}
\begin{filecontents}{jump-stack-E.listing}
public interface E extends JS<¤, ¤, ¤> {
  @Override public ¢$Γ$¢¢$ʹ$¢.¤ top();
  @Override public ¤ pop();
  @Override public P<¢$γ$¢1, E, E, ¤> ¢$γ$¢1();
  @Override public P<¢$γ$¢2, E, ¤, E> ¢$γ$¢2();
}
\end{filecontents}
\begin{filecontents}{jump-stack-example.listing}
public static void jump_stack_use_cases(){
  P<
    ¢$γ$¢1,                             // Top   
    P<¢$γ$¢1,P<¢$γ$¢2,E,¤,E>,P<¢$γ$¢2,E,¤,E>,E>,// Rest 
    P<¢$γ$¢1,P<¢$γ$¢2,E,¤,E>,P<¢$γ$¢2,E,¤,E>,E>,// jump(¢$γ$¢1) 
    E                               // jump(¢$γ$¢2)                      
  > _1 = JS.empty.¢$γ$¢2().¢$γ$¢1().¢$γ$¢1();
  E _2 = _1.jump_¢$γ$¢2();
  P<
    ¢$γ$¢1,             // Top
    P<¢$γ$¢2,E,¤,E>,    // Rest
    P<¢$γ$¢2,E,¤,E>     // jump(¢$γ$¢1)
    ,E              // jump(¢$γ$¢2)
  > _3 = _1.jump_¢$γ$¢1();
}
\end{filecontents}
\begin{filecontents}{jump-stack.listing}
public interface JS<  // ¢$1+k$¢ generic parameters
  //As a convention, we use JS with its raw type when no parameters are introduced 
    Rest extends JS, 
    J_¢$γ$¢1 extends JS, 
    J_¢$γ$¢2 extends JS 
> {
  ¢$Γ$¢¢$ʹ$¢ top();
  Rest pop();
  JS ¢$γ$¢1();
  JS ¢$γ$¢2();
  J_¢$γ$¢1 jump_¢$γ$¢1();
  J_¢$γ$¢2 jump_¢$γ$¢2();
  interface ¤ extends JS<¤, ¤, ¤> { ¢$…$¢ }
  public interface E extends JS<¤, ¤, ¤> { ¢$…$¢ }
  public static final E empty = null;
  public interface P<// ¢$2+k$¢ generic arguments:
      Top extends ¢$Γ$¢, 
      Rest extends JS,    
      J_¢$γ$¢1 extends JS, 
      J_¢$γ$¢2 extends JS
  > extends P¢$ʹ$¢<Top, Rest, J_¢$γ$¢1, J_¢$γ$¢2, 
        P<Top, Rest, J_¢$γ$¢1, J_¢$γ$¢2>
  > { /**/ }
}
\end{filecontents}
\begin{filecontents}{jump-stack-push.listing}
private interface P¢$ʹ$¢<
// ¢$2+k+1$¢ generic arguments: 
  Top extends ¢$Γ$¢,   
  Rest extends JS, 
  J_¢$γ$¢1 extends JS, 
  J_¢$γ$¢2 extends JS,
  Me extends JS
> extends JS<Rest, J_¢$γ$¢1, J_¢$γ$¢2> {
   public Top top();
   P<¢$γ$¢1, Me, Me, J_¢$γ$¢2> ¢$γ$¢1();
   P<¢$γ$¢2, Me, J_¢$γ$¢2, Me> ¢$γ$¢2();
}
\end{filecontents}
\begin{filecontents}{mammal.listing}
class Mammals { /* ¢$…$¢ */ }
class Heap<M extends Mammals> { /* ¢$…$¢ */}
class Whales extends Mammals { /* ¢$…$¢ */}
class School<W extends Whales> 
  extends Heap<W> { /* ¢$…$¢ */}
\end{filecontents}
\begin{filecontents}{peep.listing}
public static class Peep<¢$γ$¢ extends ¢$Γ$¢¢$ʹ$¢, S extends Stack<? extends Stack<?>>> {}
public static Peep<?, E> peep(E _) { return null; } // First overloaded version of ¢\cc{peep()}¢
public static                                       // Second overloaded version of ¢\cc{peep()}¢
<Top extends ¢$Γ$¢, Rest extends Stack<?>> // Two generic parameters
Peep<Top, P<Top, Rest>>                // Function return type
peep(P<Top, Rest> _) { return null; }    // Function parameters and body
public static void peeping_into_a_stack_use_cases() {
  P<¢$γ$¢2, P<¢$γ$¢1, P<¢$γ$¢2, P<¢$γ$¢1, P<¢$γ$¢2, E>>>>> _1 = Stack.empty.¢$γ$¢2().¢$γ$¢1().¢$γ$¢2().¢$γ$¢1().¢$γ$¢2();
  Peep<¢$γ$¢2, P<¢$γ$¢2, P<¢$γ$¢1, P<¢$γ$¢2, P<¢$γ$¢1, P<¢$γ$¢2, E>>>>>> _2 = peep(_1);
  E _3 = Stack.empty;
  Peep<?, E> _4 = peep(_3);
}
\end{filecontents}
\begin{filecontents}{prefix-proof.cases.listing}
static void accepts() {
  A.build.$();
  A.build.¢$σ$¢1().¢$σ$¢3().$();
  A.build.¢$σ$¢1().¢$σ$¢2().$(); 
  A.build.¢$σ$¢1().¢$σ$¢1().¢$σ$¢2().¢$σ$¢3().¢$σ$¢1().¢$σ$¢2().$(); 
}
static void rejects() {
  A.build.¢$σ$¢1().$();
  A.build.¢$σ$¢2();
  A.build.¢$σ$¢1().¢$σ$¢2().¢$σ$¢3();
  A.build.¢$σ$¢1().¢$σ$¢1().¢$σ$¢2().¢$σ$¢3().¢$σ$¢1().$();  
}
\end{filecontents}
\begin{filecontents}{prefix-proof.configuration.listing}
static class L // Encodes set ¢$L\subseteq \Sigma^*$¢, type of accept 
  { /* empty */  }
public interface E { /* Empty stack configuration */ }
interface ¤ { /* Error configuration. */ }
\end{filecontents}
\begin{filecontents}{prefix-proof.full.listing}
static class A { // Encode automaton ¢$A$¢
  static class L // Encodes set ¢$L\subseteq \Sigma^*$¢, type of accept 
    { /* empty */  }
  public interface E { /* Empty stack configuration */ }
  interface ¤ { /* Error configuration. */ }
  // Configuration of the automaton
  interface C¢$γ$¢1< // Configuration when ¢$\gamma_1$¢ is at top
    Rest, JR¢$γ$¢1, JR¢$γ$¢2
  > extends 
    ¢$γ$¢1¢$σ$¢1_Push_¢$γ$¢1¢$γ$¢1¢$γ$¢2<Rest,JR¢$γ$¢1,JR¢$γ$¢2,C¢$γ$¢1<Rest, JR¢$γ$¢1, JR¢$γ$¢2>>
  {
    L $();
  }
  interface C¢$γ$¢2< // Configuration when ¢$\gamma_2$¢ is at top
    Rest, JR¢$γ$¢1, JR¢$γ$¢2
  > extends 
    ¢$γ$¢2¢$σ$¢1_Push_¢$γ$¢2¢$γ$¢2<Rest,JR¢$γ$¢1,JR¢$γ$¢2>
  { 
    Rest ¢$σ$¢2();
    JR¢$γ$¢1 ¢$σ$¢3();
  }
  interface ¢$γ$¢1¢$σ$¢1_Push_¢$γ$¢1¢$γ$¢1¢$γ$¢2<Rest,JR¢$γ$¢1,JR¢$γ$¢2,P extends C¢$γ$¢1<Rest, JR¢$γ$¢1, JR¢$γ$¢2 >>{
    // Sidekick of ¢$\delta(\gamma_1,\sigma_1)=\textsf{push}(\gamma_1,\gamma_1,\gamma_2)$¢
    C¢$γ$¢2<C¢$γ$¢1<P, Rest, JR¢$γ$¢2>,P,JR¢$γ$¢2> ¢$σ$¢1();
  }
  interface ¢$γ$¢2¢$σ$¢1_Push_¢$γ$¢2¢$γ$¢2<Rest,JR¢$γ$¢1,JR¢$γ$¢2>{
    // Sidekick of ¢$\delta(\gamma_2,\sigma_1)=\textsf{push}(\gamma_2,\gamma_2)$¢
    C¢$γ$¢2<C¢$γ$¢2<Rest, JR¢$γ$¢1, JR¢$γ$¢2>, JR¢$γ$¢1, Rest> ¢$σ$¢1();
  }
  static C¢$γ$¢1<E,¤,¤> build = null;
}
\end{filecontents}
\begin{filecontents}{prefix-proof.many.listing}
interface C¢$γ$¢1< // Configuration when ¢$\gamma_1$¢ is at top
  Rest, JR¢$γ$¢1, JR¢$γ$¢2
> extends 
  ¢$γ$¢1¢$σ$¢1_Push_¢$γ$¢1¢$γ$¢1¢$γ$¢2<Rest,JR¢$γ$¢1,JR¢$γ$¢2,C¢$γ$¢1<Rest, JR¢$γ$¢1, JR¢$γ$¢2>>
{
}
interface C¢$γ$¢2< // Configuration when ¢$\gamma_2$¢ is at top
  Rest, JR¢$γ$¢1, JR¢$γ$¢2
> extends 
  ¢$γ$¢2¢$σ$¢1_Push_¢$γ$¢2¢$γ$¢2<Rest,JR¢$γ$¢1,JR¢$γ$¢2>
{ 
}
static C¢$γ$¢1<E,¤,¤> build = null;
\end{filecontents}
\begin{filecontents}{proof.cases.listing}
static void isL(L l) {/**/}
static void accepts() {
  isL(A.build.$());
  isL(A.build.¢$σ$¢1().¢$σ$¢3().$());
  isL(A.build.¢$σ$¢1().¢$σ$¢2().$()); 
  isL(A.build.¢$σ$¢1().¢$σ$¢1().¢$σ$¢2().¢$σ$¢3().¢$σ$¢1().¢$σ$¢2().$()); 
}
static void rejects() {
  isL(A.build.¢$σ$¢1().$());
  isL(A.build.¢$σ$¢2().¢$σ$¢1().$());
  isL(A.build.¢$σ$¢1().¢$σ$¢2().¢$σ$¢3().$());
  isL(A.build.¢$σ$¢1().¢$σ$¢1().¢$σ$¢2().¢$σ$¢3().¢$σ$¢1().$());  
}
\end{filecontents}
\begin{filecontents}{proof.configuration.listing}
interface C<      // Generic parameters:
  Rest extends C, // The rest of the stack, for pop or ¢$\textsf{jump}(\gamma)$¢ operations
  JR¢$γ$¢1 extends C, // Type of ¢$~\cc{Rest}.\textsf{jump}(\gamma_1)$¢, may be rest, or anything in it. 
  JR¢$γ$¢2 extends C  // Type of ¢$~\cc{Rest}.\textsf{jump}(\gamma_2)$¢, may be rest, or anything in it.  
>
{
  ¢$Σ$¢¢$Σ$¢ $();        // ¢$δ$¢ transition on end of input; invalid language by default 
  C ¢$σ$¢1();         // ¢$δ$¢ transition on ¢$\sigma_1$¢; dead end by default
  C ¢$σ$¢2();         // ¢$δ$¢ transition on ¢$\sigma_2$¢; dead end by default
  C ¢$σ$¢3();         // ¢$δ$¢ transition on ¢$\sigma_3$¢; dead end by default
  public interface E extends C<¤,¤,¤> { /* Empty stack configuration */ }
  interface ¤ extends C<¤,¤,¤> { /* Error configuration. */ }
}
\end{filecontents}
\begin{filecontents}{proof.full.listing}
class A { // Encode automaton ¢$A$¢
  private static class ¢$Σ$¢¢$Σ$¢   // Encodes set ¢$\Sigma^*$¢, type of reject
    { /* empty */  } 
  static class L extends ¢$Σ$¢¢$Σ$¢ // Encodes set ¢$L\subseteq \Sigma^*$¢, type of accept 
    { /* empty */  }
  // Configuration of the automaton
  interface C<      // Generic parameters:
    Rest extends C, // The rest of the stack, for pop or ¢$\textsf{jump}(\gamma)$¢ operations
    JR¢$γ$¢1 extends C, // Type of ¢$~\cc{Rest}.\textsf{jump}(\gamma_1)$¢, may be rest, or anything in it. 
    JR¢$γ$¢2 extends C  // Type of ¢$~\cc{Rest}.\textsf{jump}(\gamma_2)$¢, may be rest, or anything in it.  
  >
  {
    ¢$Σ$¢¢$Σ$¢ $();        // ¢$δ$¢ transition on end of input; invalid language by default 
    C ¢$σ$¢1();         // ¢$δ$¢ transition on ¢$\sigma_1$¢; dead end by default
    C ¢$σ$¢2();         // ¢$δ$¢ transition on ¢$\sigma_2$¢; dead end by default
    C ¢$σ$¢3();         // ¢$δ$¢ transition on ¢$\sigma_3$¢; dead end by default
    public interface E extends C<¤,¤,¤> { /* Empty stack configuration */ }
    interface ¤ extends C<¤,¤,¤> { /* Error configuration. */ }
    interface C¢$γ$¢1< // Configuration when ¢$\gamma_1$¢ is at top
      Rest extends C, JR¢$γ$¢1 extends C, JR¢$γ$¢2 extends C
    > extends 
      C<Rest, JR¢$γ$¢1, JR¢$γ$¢2>   
      ,¢$γ$¢1¢$σ$¢1_Push_¢$γ$¢1¢$γ$¢1¢$γ$¢2<Rest,JR¢$γ$¢1,JR¢$γ$¢2,C¢$γ$¢1<Rest, JR¢$γ$¢1, JR¢$γ$¢2>>
    {
      @Override L $();
    }
    interface C¢$γ$¢2< // Configuration when ¢$\gamma_2$¢ is at top
      Rest extends C, JR¢$γ$¢1 extends C, JR¢$γ$¢2 extends C
    > extends 
      C<Rest, JR¢$γ$¢1, JR¢$γ$¢2>
      ,¢$γ$¢2¢$σ$¢1_Push_¢$γ$¢2¢$γ$¢2<Rest,JR¢$γ$¢1,JR¢$γ$¢2>
    { 
      @Override Rest ¢$σ$¢2();
      @Override JR¢$γ$¢1 ¢$σ$¢3();
    }
    interface ¢$γ$¢1¢$σ$¢1_Push_¢$γ$¢1¢$γ$¢1¢$γ$¢2<Rest extends C,JR¢$γ$¢1 extends C,JR¢$γ$¢2 extends C,P extends C¢$γ$¢1<Rest, JR¢$γ$¢1, JR¢$γ$¢2 >>{
      // Sidekick of ¢$\delta(\gamma_1,\sigma_1)=\textsf{push}(\gamma_1,\gamma_1,\gamma_2)$¢
      C¢$γ$¢2<C¢$γ$¢1<P, Rest, JR¢$γ$¢2>,P,JR¢$γ$¢2> ¢$σ$¢1();
    }
    interface ¢$γ$¢2¢$σ$¢1_Push_¢$γ$¢2¢$γ$¢2<Rest extends C,JR¢$γ$¢1 extends C,JR¢$γ$¢2 extends C>{
      // Sidekick of ¢$\delta(\gamma_2,\sigma_1)=\textsf{push}(\gamma_2,\gamma_2)$¢
      C¢$γ$¢2<C¢$γ$¢2<Rest, JR¢$γ$¢1, JR¢$γ$¢2>, JR¢$γ$¢1, Rest> ¢$σ$¢1();
    }
  }
    static C¢$γ$¢1<E,¤,¤> build = null;
}
\end{filecontents}
\begin{filecontents}{proof.headers.listing}
private static class ¢$Σ$¢¢$Σ$¢   // Encodes set ¢$\Sigma^*$¢, type of reject
  { /* empty */  } 
static class L extends ¢$Σ$¢¢$Σ$¢ // Encodes set ¢$L\subseteq \Sigma^*$¢, type of accept 
  { /* empty */  }
\end{filecontents}
\begin{filecontents}{proof.many.listing}
  interface C¢$γ$¢1< // Configuration when ¢$\gamma_1$¢ is at top
    Rest extends C, JR¢$γ$¢1 extends C, JR¢$γ$¢2 extends C
  > extends 
    C<Rest, JR¢$γ$¢1, JR¢$γ$¢2>   
  {
  }
  interface C¢$γ$¢2< // Configuration when ¢$\gamma_2$¢ is at top
    Rest extends C, JR¢$γ$¢1 extends C, JR¢$γ$¢2 extends C
  > extends 
    C<Rest, JR¢$γ$¢1, JR¢$γ$¢2>
  { 
  }
  static C¢$γ$¢1<E,¤,¤> build = null;
\end{filecontents}
\begin{filecontents}{spda.listing}
public static abstract class Q<S extends Stack<?>, Top extends ¢$Γ$¢¢$ʹ$¢> {
  private static final class ¤ extends Q<Stack<?>, ¢$Γ$¢¢$ʹ$¢.¤> {/**/}
  public static final class q0 extends Q<E,¢$Γ$¢¢$ʹ$¢.¤>{
    public SingleP_¢$γ$¢2<E> ¢$σ$¢1() { return null; }
  }
  public static abstract class q1<S extends Stack<?> , T extends ¢$Γ$¢¢$ʹ$¢> extends Q<S,T> {
    private static final class ¤ extends q1<E, ¢$Γ$¢¢$ʹ$¢.¤> {/**/}
    public static final class q1_¢$γ$¢1<Rest extends Stack<?>> extends q1<P<¢$γ$¢1,Rest>,¢$γ$¢1> {/**/}
    public static final class q1_¢$γ$¢2<Rest extends Stack<?>> extends q1<P<¢$γ$¢2,Rest>,¢$γ$¢2> {
      public NoOp2<Rest> ¢$σ$¢1() { return null; }
    }
  }
  public static abstract class q2<S extends Stack<?> , T extends ¢$Γ$¢¢$ʹ$¢> extends Q<S,T> {
    public static final class q2_E extends q2<E, ¢$Γ$¢¢$ʹ$¢.¤> {
      public DoubleP_¢$γ$¢1_¢$γ$¢2 ¢$σ$¢1() { return null; }
    }
    public static final class q2_¢$γ$¢1<S extends Stack<?>> extends q2<S,¢$γ$¢1> {/**/}
    public static final class q2_¢$γ$¢2<S extends Stack<?>> extends q2<S,¢$γ$¢2> {
      public DoubleP_¢$γ$¢1_¢$γ$¢1<S> ¢$σ$¢1() { return null; }
    }
  }
  public static abstract class q3<S extends Stack<?>, T extends ¢$Γ$¢¢$ʹ$¢> extends Q<S,T> {
    public static final class q3_¢$γ$¢1<Rest extends Stack<?>> extends q3<P<¢$γ$¢1,Rest>,¢$γ$¢1> {/**/}
    public static final class q3_¢$γ$¢2<Rest extends Stack<?>> extends q3<P<¢$γ$¢2,Rest>,¢$γ$¢2> {/**/}
    private static final class ¤ extends q3<E, ¢$Γ$¢¢$ʹ$¢.¤> {/**/}
  }
}
\end{filecontents}
\begin{filecontents}{stack.listing}
public static abstract class Stack<Rest extends Stack<?>> { 
  public abstract ¢$Γ$¢¢$ʹ$¢ top();      
  public abstract Rest pop();    
  public abstract Stack<?> ¢$γ$¢1();  // Push type ¢\cc{\scriptsize $\Gamma'.\Gamma.\gamma1$}¢
  public abstract Stack<?> ¢$γ$¢2();  // Push type ¢\cc{\scriptsize $\Gamma'.\Gamma.\gamma2$}¢ 
  public static class P<Top extends ¢$Γ$¢, Rest extends Stack<?>> 
    extends Stack<Rest> { // Type of a non-empty stack: 
       @Override public Top top() { return null; } 
       @Override public Rest pop() { return null; }
       @Override public P<¢$γ$¢1, P<Top,Rest>> ¢$γ$¢1() { return null; } 
       @Override public P<¢$γ$¢2, P<Top,Rest>> ¢$γ$¢2() { return null; }
  }
  public static final class E 
    extends Stack<¤> { // Type of an empty stack
      @Override public ¢$Γ$¢¢$ʹ$¢.¤ top() { return null; }
      @Override public ¤ pop() { return null; } 
      @Override public P<¢$γ$¢1, E> ¢$γ$¢1() { return null; } 
      @Override public P<¢$γ$¢2, E> ¢$γ$¢2() { return null; }
  }
  public static final E empty = null; 
  private static final class ¤ 
    extends Stack<¤> { // Type of pop from empty stack 
      @Override public ¢$Γ$¢¢$ʹ$¢.¤ top() { return null; }
      @Override public ¤ pop() { return null; } 
      @Override public ¤ ¢$γ$¢1() { return null; } 
      @Override public ¤ ¢$γ$¢2() { return null; }
  }
}
\end{filecontents}
\begin{filecontents}{stack-use-cases.listing}
public static void use_case_of_stack() {
  // Create a stack a with five items in it:
  P<¢$γ$¢1, P<¢$γ$¢1, P<¢$γ$¢2, P<¢$γ$¢1, P<¢$γ$¢1, E>>>>> _1 = Stack.empty.¢$γ$¢1().¢$γ$¢1().¢$γ$¢2().¢$γ$¢1().¢$γ$¢1();
  P<¢$γ$¢1, P<¢$γ$¢2, P<¢$γ$¢1, P<¢$γ$¢1, E>>>> _2 = _1.pop(); // ✓ Pop one item
  P<¢$γ$¢2, P<¢$γ$¢1, P<¢$γ$¢1, E>>> _3 = _2.pop(); // ✓ Pop another item
  P<¢$γ$¢1, P<¢$γ$¢1, E>> _4 = _3.pop(); // ✓ Pop yet another item
  P<¢$γ$¢1, E> _5 = _4.pop(); // ✓ Pop penultimate item
  ¢$γ$¢1 _6 = _5.top(); // ✓ Examine last item
  E _7 = _5.pop(); // ✓ Pop last item
  Stack.¤ _8 = _7.pop(); // ✗ Cannot pop from an empty stack
  ¢$Γ$¢¢$ʹ$¢.¤ _9 = _7.top(); // ✗ empty stack has no top element
} 
\end{filecontents}
\begin{filecontents}{camel-apache.java.fragment}
from("direct:a").choice()
    .when(header("foo").isEqualTo("bar"))
      .to("direct:b")
    .when(header("foo").isEqualTo("cheese"))
      .to("direct:c")
    .otherwise()
      .to("direct:d");
\end{filecontents}
\begin{filecontents}{fajita-bootstrap.fragment}
new BNF()
  .with(BNFTerminals.class)
  .with(BNFSymbols.class)
  .start(BNF)
  .derive(BNF)
    .to(Header).and(Body).and(Footer)
  .derive(Header)
    .to(Variables).and(Terminals)
    .or(Terminals).and(Variables)
  .derive(Variables)
    .to(with, Variable.class)
  .derive(Terminals)
    .to(with, Terminal.class)
  .derive(Body)
    .to(Start).and(Rules)
  .derive(Start)
    .to(start, Variable)
  .derive(Rules)
    .to(Rule).and(Rules)
    .or(Rule)
  .derive(Conjunctions)
    .to(First_Conjunction).and(Conjunctions)
  .derive(First_Conjunction)
    .to(to,Symbol).and(Symbols)
    .or(toNone)
  .derive(Conjunctions)
    .to(Conjunction).and(Conjunctions)
    .orNone()
  .derive(Conjunction)
    .to(or,Symbol).and(Symbols)
    .orNone()
  .derive(Symbols)
    .toNone()
    .or(and, Symbol).and(Symbols)
  .derive(Symbol)
    .to(Verb)
    .or(Verb,Noun)
    .or(Variable)
  .derive(Footer)
    .to(go)
.go();
 
\end{filecontents}
\begin{filecontents}{fajita-nouns.fragment}
enum BNFVariables implements Variable {
  BNF, Header, Body, Footer,
  Terminals, Variables, Start,
  Rules,Rule,Conjunctions, Extra_Conjunctions,
  First_Conjunction, Extra_Conjunction, Symbol_Sequence,
  Symbol, Variable, Noun;
}
\end{filecontents}
\begin{filecontents}{fajita-verbs.fragment}
enum BNFTerminals implements Terminal {
  toNone,orNone,go,// No parameters
  start,derive // One parameter
  with, // One parameter, overloaded
  or,and,to, // One parameter (or more), overloaded, variadic
  ;
\end{filecontents}
\begin{filecontents}{fajita-verbs-nouns.fragment}
.to(male)
.to(with, Terminal.class)
.to(with, Variable.class)
.to(start, Variable)
\end{filecontents}
\begin{filecontents}{jOOQ.java.fragment}
create
  .select(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, count())
  .from(AUTHOR)
  .join(BOOK).on(AUTHOR.ID.equal(BOOK.AUTHOR_ID))
  .where(BOOK.LANGUAGE.eq("DE"))
  .and(BOOK.PUBLISHED.gt(date("2008-01-01")))
  .groupBy(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
  .having(count().gt(5))
  .orderBy(AUTHOR.LAST_NAME.asc().nullsFirst())
  .limit(2)
  .offset(1);
\end{filecontents}
\begin{filecontents}{jOOQ-mini.java.fragment}
.when(header(foo).isEqualTo("bar")).
\end{filecontents}
\begin{filecontents}{stringbuilder-example.fragment}
String time(int hours, int minutes, int seconds) {
  return new StringBuilder()
    .append(hours)
    .append(':')
    .append(minutes)
    .append(':')
    .append(seconds)
    .toString();
}
\end{filecontents}
\begin{filecontents}{toilette-generation.fragment}
new BNF()
  .with(ToiletteTerminals.class)
  .with(ToiletteSymbols.class)
  .start(Visitors)
  .derive(Visitors).to(Down_Visitors)
  .derive(Down_Visitors)
    .to(Down_Visitor).and(Down_Visitors)
    .or(Raising_Visitor).and(Up_Visitors)
    .orNone()
  .derive(Up_Visitors)
    .to(Up_Visitor).and(Up_Visitors)
    .or(Lowering_Visitor).and(Down_Visitors)
    .orNone()
  .derive(Up_Visitor).to(male).and(urinate)
  .derive(Down_Visitor)
    .to(female).and(Action)
    .or(male).and(defecate)
  .derive(Raising_Visitor).to(male).and(raise).and(urinate)
  .derive(Lowering_Visitor)
    .to(female).and(lower).and(Action)
    .or(male).and(lower).and(defecate)
  .derive(Activity)
    .to(urinate)
    .or(defecate)
  .go();
 
\end{filecontents}
\begin{filecontents}{toilette-terminals.fragment}
enum ToiletteTerminals implements Terminal {
  male, female,
  urinate, defecate,
  lower, raise;
}
\end{filecontents}
\begin{filecontents}{toilette-variables.fragment}
enum ToiletteVariables implements Variable {
  Visitors, Down_Visitors, Up_Visitors,
  Up_Visitor, Down_Visitor,
  Lowering_Visitor, Raising_Visitor,
  Activity
};
\end{filecontents}
\begin{document}


\maketitle
\hfill
\parbox{40ex}{  \begin{flushright}
    \scriptsize\itshape ``\NonCitingUse{Java} generics are 100\% pure syntactic sugar,
    and do not support meta-programming''\footnotemark
  \end{flushright}
}
\newline

\footnotetext{Found on stackoverflow:
  \tiny
      \url{http://programmers.stackexchange.com/questions/95777/generic-programming-how-often-is-it-used-in-industry}
    }

\begin{abstract}
  This paper is a theoretical study of a practical problem:
  the automatic generation of \NonCitingUse{Java} Fluent APIs from their specification.
We explain why the problem's core lies with 
  the expressive power of \NonCitingUse{Java} generics.
Our main result is that automatic generation is possible whenever 
  the specification is an instance of the set of deterministic context-free languages,
  a set which contains most ``practical'' languages.
Other contributions include a collection of techniques and idioms of
  the limited meta-programming possible with \NonCitingUse{Java} generics, 
  and an empirical measurement demonstrating that the runtime of
  the ``javac'' compiler of \NonCitingUse{Java} may be exponential in
  the program's length, even for programs composed of 
  a handful of lines and which do not rely on overly 
  complex use of generics.
 \end{abstract}

\section{Introduction}
Ever after their inception\urlref{http://martinfowler.com/bliki/FluentInterface.html} \emph{fluent APIs}
  increasingly gain popularity~\cite{Hibernate:06,Freeman:Pryce:06,Larsen:2012} and research
  interest~\cite{Deursen:2000,Kabanov:2008}.
In many ways, fluent APIs are a kind of
  \emph{internal} \emph{\textbf Domain \textbf Specific \textbf Language}:
They make it possible to enrich a host programming language without changing it.
Advantages are many: base language tools (compiler, debugger, IDE, etc.) remain
  applicable, programmers are saved the trouble of learning a new syntax, etc.
However, these advantages come at the cost of expressive power;
  in the words of Fowler:
  ‟\emph{Internal DSLs are limited by the syntax and structure of your base language.}”†
  {M. Fowler, \emph{Language Workbenches: The Killer-App for Domain Specific Languages?},
    2005
    \newline
  \url{http://www.martinfowler.com/articles/languageWorkbench.html＃InternalDsl}}.
Indeed, in languages such as \CC, fluent APIs
  often make extensive use of operator overloading (examine, e.g., \textsf{Ara-Rat}~\cite{Gil:Lenz:07}),
  but this capability is not available in \Java.

Despite this limitation, fluent APIs in \Java can be rich and expressive, as demonstrated
  in \cref{figure:DSL} showing use cases of the DSL of Apache Camel~\cite{Ibsen:Anstey:10}
(open-source integration framework),
and that of jOOQ\urlref{http://www.jooq.org}, a framework for writing
  SQL in \Java, much like Linq~\cite{Meijer:Beckman:Bierman:06}.

\begin{figure}[H]
  \caption{\label{figure:DSL} Two examples of \Java fluent API}
  \begin{tabular}{@{}c@{}c@{}}
    \parbox[c]{44ex}{\javaInput[]{camel-apache.java.fragment}} &
    \hspace{-3ex} \parbox[c]{59ex}{\javaInput[]{jOOQ.java.fragment}}⏎
    \textbf{(a)} Apache Camel & \textbf{(b)} jOOQ
  \end{tabular}
\end{figure}

Other examples of fluent APIs in \Java are abundant:
  jMock~\cite{Freeman:Pryce:06},
  Hamcrest\urlref{http://hamcrest.org/JavaHamcrest/},
  EasyMock\urlref{http://easymock.org/},
  jOOR\urlref{https://github.com/jOOQ/jOOR},
  jRTF\urlref{https://github.com/ullenboom/jrtf}
  and many more.

\subsection{A Type Perspective on Fluent APIs}
\Cref{figure:DSL}(B) suggests that jOOQ imitates SQL,
but, is it possible at all to produce a fluent API
for the entire SQL language,
or XPath, HTML, regular expressions, BNFs, EBNFs, etc.?
Of course, with no operator overloading it is impossible
to fully emulate tokens; method names though make a good substitute for tokens, as done
in ‟\lstinline{.when(header(foo).isEqualTo("bar")).}” (\cref{figure:DSL}).
The questions that motivate this research are:
\begin{quote}
  \begin{itemize}
    \item Given a specification of a DSL, determine whether there exists
        a fluent API that can be made for this specification?
    \item In the cases that such fluent API is possible,
      can it be produced automatically?
    \item Is it feasible to produce a \emph{compiler-compiler} such as Bison~\cite{Bison:manual}
        to convert a language specification into a fluent API?
\end{itemize}
\end{quote}

Inspired by the theory of formal languages and automata,
  this study explores what can be done with fluent APIs in \Java.

Consider some fluent API (or DSL) specification, permitting only certain call
chains and disallowing all others.
Now, think of the formal language that defines the set of these permissible chains.
We prove that there is always a \Java type definition that
  \emph{realizes} this fluent definition, provided that this
  language is \emph{deterministic context-free}, where
\begin{itemize}
  \item In saying that a type definition \emph{realizes} a specification of fluent
    API, we mean that call chains that conform with the API definition compile
    correctly, and, conversely, call chains that are forbidden by the API
    definition do not type-check, resulting in an appropriate compiler error.
  \item Roughly speaking, deterministic context-free languages are those
    context-free languages that can be recognized by an LR parser†{The ‟L"
    means reading the input left to right; the ‟R" stands for rightmost derivation}~\cite{Aho:Sethi:Ullman:86}.
    \par
    An important property of this family is that none of its members is ambiguous.
    Also, it is generally believed that most practical programming languages
    are deterministic context-free.
\end{itemize}

A problem related to that of recognizing a formal language,
is that of parsing, i.e., creating, for input which is within the language,
  a parse tree according to the language's grammar.
In the domain of fluent APIs, the distinction between recognition and parsing is
  in fact the distinction between compile time and runtime.
Before a program is run, the compiler checks whether the fluent API call is legal,
  and code completion tools will only suggest legal extensions of a current call chain.

In contrast, a parse tree can only be created at runtime.
Some fluent API definitions create the parse-tree
  iteratively, where each method invocations in the call chain adding
  more components to this tree.
However, it is always possible to generate this tree in ‟batch” mode:
This is done by maintaining a \emph{fluent-call-list} which
  starts empty and grows at runtime by having each method invoked add to it
  a record storing the method's name and values of its parameters.
The list is completed at the end of the fluent-call-list, at which point it is fed to an appropriate parser that
  converts it into a parse tree (or even an AST).

\subsection{Contribution}
The answers we provide for the three questions above are:
\begin{quote}
  \begin{enumerate}
  \item If the DSL specification is that of a deterministic context-free
    language, then a fluent API exists for the language, but we do not know
    whether such a fluent API exists for more general languages.
  \par
  Recall that there are universal cubic time parsing
  algorithms~\cite{Cocke:1969,Earley:1970,Younger:1967} which can parse (and recognize) any
  context-free language. What we do not know is whether algorithms of this sort
  can be encoded within the framework of the \Java type system.
  \item
  There exists an algorithm to generate a fluent API that realizes any
  deterministic context-free languages. Moreover, this fluent API can create
  at runtime, a parse tree for the given language. This parse tree can then be
  supplied as input to the library that implements the language's semantics.
  \item
  Unfortunately, a general purpose compiler-compiler
  is not yet feasible with the current algorithm.
  \begin{itemize}
    \item One difficulty is usual in the fields of formal languages:
      The algorithm is complicated and relies on
      modules implementing complicated theoretical results, which, to the best of our
      knowledge, have never been implemented.
    \item Another difficulty is that a certain design decision in the
      implementation of the standard \texttt{javac} compiler is likely to make it choke on the
      \Java code generated by the algorithm.
  \end{itemize}
  \end{enumerate}
\end{quote}

Other concrete contributions made by this work include
\begin{itemize}
  \item the understanding that the definition of fluent APIs is analogous to
      the definition of a formal language.
  \item a lower bound (deterministic pushdown automata)
    on the theoretical ‟computational complexity” of the \Java type system.
  \item an algorithm for producing a fluent API for deterministic context-free languages.
  \item a collection of generic programming techniques, developed towards this algorithm.
  \item a demonstration that the runtime of Oracle's \texttt{javac} compiler may be exponential in the program size.
\end{itemize}

\subsection{Related Work}

It has long been known
  that \CC templates are Turing complete in the following precise sense:

\begin{Proposition}
  \label{Theorem:Gutterman}
  For every Turing machine,~$m$, there exists a \CC program,~$Cₘ$ such that
    compilation of~$Cₘ$ terminates if and only if
      Turing-machine~$m$ halts.
      Furthermore, program~$Cₘ$ can be effectively generated from~$m$~\cite{Gutterman:2003}.
\end{Proposition}

Intuitively, this is due to the fact that templates in \CC
  feature both recursive invocation and conditionals (in the form of
  ‟\emph{template specialization}”).

In the same fashion, it should be mundane to make the judgment that
  \Java's generics are not Turing-complete since they offer no conditionals.
Still, even though there are time complexity results regarding type systems in functional
  languages, we failed to find similar claims for \Java.

Specialization, conditionals, \kk{typedef}s and other features of \CC templates,
  gave rise to many advancements in template/generic/generative programming
  in the language~\cite{Austern:98,Musser:Stepanov:1989,Backhouse:Jansson:1999,Dehnert:Stepanov:2000},
  including e.g., applications in numeric libraries~\cite{Veldhuizen:95,Vandevoorde:Josuttis:02},
  symbolic derivation~\cite{Gil:Gutterman:98}
  and a full blown template library~\cite{Abrahams:Gurtovoy:04}.

Garcia et al.~\cite{Garcia:Jarvi:Lumsdaine:Siek:Willcock:03} compared
  the expressive power of generics in half a dozen major programming languages.
  In several ways, the \Java approach~\cite{Bracha:Odersky:Stoutamire:Wadler:98}
  did not rank as well as others.

Not surprisingly, work on meta-programming using \Java generics,
  research concentrating on other means for enriching the language,
  most importantly annotations~\cite{Papi:08}.

The work on SugarJ~\cite{Erdweg:2011} is only one of many other attempts
  to achieve the embedded DSL effect of fluent APIs by language extensions.

Suggestions for semi-automatic generation can be found in the work of Bodden~\cite{Bodden:14} and
  on numerous locations in the web.
None of these materialized into an algorithm or analysis of complexity.
However, there is a software artifact (fluflu\urlref{https://github.com/verhas/fluflu})
  that automatically generates a fluent API that obeys the transitions
    of a given finite automaton.
 
\textbf{Outline.} \small
\Cref{section:fluent} is a brief reminder of method chaining,
  and fluent APIs, accompanied a discussion of how this work is related to type states.
It is followed by a similar reminder of context-free languages, pushdown automata,
  and such in \cref{section:pushdown}.
Based on the vocabulary established this far,
  the main result is stated in~\cref{section:result}.

Towards the proof in \cref{section:proof}, \cref{section:toolkit}
  shows idioms and techniques for encoding computation with  
  the \Java type-checker.
\Cref{section:jump} makes use of these for encoding
  ``jump-stack'', a non-trivial data-structure,
  which is used, with suitable modifications, in the proof.

In \cref{section:applicability}, we discuss the challenges in
  translating the proof into a compiler-compiler for fluent APIs.
In particular, this section demonstrates our claim (that may be
  surprising to some) that the standard \Java compiler may spend
  an exponential time on compiling rather simple programs.
\cref{section:zz} concludes with directions for further research.
\normalsize

\section{Method Chaining, Fluent APIs, and, Type States}
\label{section:fluent}
The pattern ‟invoke function on variable \cc{sb}”, specifically with
  a function named \cc{append}, occurs six times in the code in \cref{Figure:chaining}(a), designed
  to format a clock reading, given as integers hours, minutes and
  seconds.

\begin{figure}[H]
  \caption[Example of recurring method invocations]{\label{Figure:chaining}    Recurring invocations of the pattern ‟invoke function on the same
      receiver”, before, and after method chaining.
  }    \begin{tabular}{@{}cc@{}}  \begin{lcode}[minipage,width=44ex,box align=center]{Java}
String time(int hours, int minutes, int seconds) {¢¢
  final StringBuilder sb = new StringBuilder();
  sb.append(hours);
  sb.append(':');
  sb.append(minutes);
  sb.append(':');
  sb.append(seconds);
  return sb.toString();
}\end{lcode}
\hfill
&
\hspace{1ex}
  \begin{lcode}[minipage,width=44ex,box align=center]{Java}
String time(int hours, int minutes, int seconds) {¢¢
    return new StringBuilder()
      ¢¢.append(hours).append(':')
      ¢¢.append(minutes).append(':')
      ¢¢.append(seconds)
      ¢¢.toString();
}\end{lcode}
⏎
\textbf{(a)} before & \textbf{(b)} after
\end{tabular}
\end{figure}

Some languages, e.g., \Smalltalk offer syntactic sugar, called \emph{cascading},
  for abbreviating this pattern.
\emph{Method chaining} is a ‟programmer made” syntactic sugar serving the same purpose:
  If a method~$f$ returns its receiver, i.e., \kk{this},
  then, instead of the series of two commands: \mbox{\cc{o.$f$(); o.$g$();}}, clients can write
  only one: \mbox{\cc{o.$f$().$g$();}}.
  \cref{Figure:chaining}(b) is the method chaining
  (also, shorter and arguably clearer) version of
  \cref{Figure:chaining}(a).
It is made possible thanks to the designer of class \cc{StringBuilder} ensuring that 
  all overloaded variants of
  \cc{append} return their receiver.

The distinction between \emph{fluent API} and method chaining is the identity of the receiver:
In method chaining, all methods are invoked on the same object, whereas in fluent API
the receiver of each method in the chain may be arbitrary.
Fluent APIs are more interesting for this reason.
Consider, e.g., the following \Java code fragment (drawn from JMock~\cite{Freeman:Pryce:06})
\[
  \cc{allowing(any(Object.\kk{class})).method("get.*").withNoArguments();}
\]
Let the return type of function \cc{allowing} (respectively \cc{method}) be denoted by~$τ₁$
(respectively~$τ₂$).
Then, the fact that~$τ₁≠τ₂$ means that the set of methods that can be placed after the dot
in the partial call chain~$\cc{allowing(any(Object.\kk{class})).}$
is not necessarily the same set of methods that can be placed after the 
dot in the partial call chain \[
\cc{allowing(any(Object.\kk{class})).method("get.*").}.
\]
This distinction makes it possible to design expressive and rich fluent APIs, in which a
sequence of ‟chained” calls is not only readable, but also robust, in the sense that the
sequence is type correct only when it makes sense semantically.

There is a large body of research on \emph{type-states} 
(See e.g., review articles such
  as~\cite{Aldrich:Sunshine:2009,Bierhoff:Aldrich:2005}).
Informally, an object that belongs to a certain type, has
type-states, if not all methods defined in this object's class are applicable
to the object in all states it may be in.
As it turns out, objects with type states are quite frequent: a recent study~\cite{Beckman:11} estimates
  that about 7.2％ of \Java classes define protocols, that can be interpreted as type-state.

In a sense, type states define the ``language'' of the protocol of an object. 
The protocol of the type-state \cc{Box} class defined in \cref{Figure:box} 
  admits the chain \cc{\kk{new} Box().open().close()} but not
  the chain \cc{\kk{new} Box().open().open()}.

\begin{figure}[H]
  \caption{\label{Figure:box}Fluent API of a box object, defined by a DFA and a table}
  \begin{tabular}{cc}
    \hspace{7ex}\parbox[c]{40ex}{      \begin{tabular}[align=center]{m{7ex} | m{9ex} @{}| m{9ex}}
        & \cc{open()} & \cc{close()}⏎ \hline
        ‟closed”\ & \color{blue}{\emph{become ‟open”}} & \color{red}{\emph{runtime error}}⏎\hline
        ‟open” & \color{red}{\emph{runtime error}} & \color{blue}{\emph{become ‟closed”}}⏎
      \end{tabular}
    } &
    \hspace{-1ex}\parbox[c]{40ex}{\begin{tikzpicture}
\tikzstyle{state-style}=[state,every node={draw=black},font=\scriptsize,text width=5ex,align=center,on grid,node distance=13ex]

\node[state-style,accepting] (closed)[blue] {closed};
\node[state-style,accepting] (opened) [blue,right=2.9 of closed] {opened};
\node[state-style,text width=4ex] (error) [above right=of closed,red] {runtime error};


\path[->,distance = 2ex,above,thick] 

				(closed) edge[below] node {\cc{open()}} (opened)
				(opened) edge[bend left,below] node {\cc{close()}} (closed)
				(closed) edge[bend left,above left] node {\cc{close()}} (error)
				(opened) edge[bend right,right] node {\cc{open()}} (error);
\draw[<-] (closed) -- node[below left] {start} ++(-5ex,4ex);
\end{tikzpicture}
 }
    ⏎⏎
    \hspace{0ex}\textbf{(a)} Definition by table & \hspace{-2ex}\textbf{(b)} Definition by DFA
  \end{tabular}
\end{figure}

As mentioned above, tools such as fluflu realize
  type-state based on their finite automaton description.
Our approach is a bit more expressive: examine the language $L$ defined by the type-state, 
  e.g., in the box example,  
        \[
          L = \big(\cc{.open().close()}\big)^*\big(\cc{.open()}\:|\:ε\big).
        \]
If $L$ is deterministic context-free, a fluent API can be made for it. 

To make the proof concrete, consider this example of fluent API definition:
An instance of class \cc{Box} may receive two 
  method invocations: \cc{open()} and \cc{close()}, and can be in either 
  ‟open” or ‟closed” state.
Initially the instance is ‟closed”.
Its behavior henceforth is defined by \cref{Figure:box}.

To realize this definition, we need a type definition by which \cc{\kk{new} Box().open().close()}, more generally
  blue, or accepting states in the figure, type-check.
Conversely, with this type definition, compile time type error should occur in \cc{\kk{new} Box().close()},
  and, more generally, in the red state.

Some skill is required to make this type definition: proper design of class \cc{Box}, perhaps with
  some auxiliary classes extending it, an appropriate method definition here and there, etc.
 
\section{Context-Free Languages and Pushdown Automata: Reminder and Terminology}
\label{section:pushdown}
Notions discussed here are probably common knowledge
 (see e.g.,~\cite{Hopcroft:Ullman:01,Linz:2001} for a text book description,
 or~\cite{Autebert:97} for a scientific review).
The purpose here is to set a unifying common vocabulary.

Let~$Σ$ be a finite alphabet of \emph{terminals} (often called input characters or tokens).
A \emph{language} over~$Σ$
  is a subset of~$Σ^*$.
Keep~$Σ$ implicit henceforth.

A \emph{\textbf Nondeterministic \textbf Pushdown \textbf Automaton} (NPDA) is a device for language recognition,
  made of a nondeterministic finite automaton
  and a stack of unbounded depth of (stack) \emph{elements}.
A NPDA begins execution with a single copy of the initial element on the stack.
In each step, the NPDA
  examines the next input token,
  the state of the automaton,
  and the top of the stack.
It then pops the top element from the stack, and nondeterministically chooses which actions of
  its transition function to perform:
  Consuming the next input token,
  moving to a new state,
  or, pushing any number of elements to the stack.
Actually, any combination of these actions may be selected.

The language recognized by a NPDA is the set of strings that it accepts,
  either by reaching an accepting state or by encountering an empty stack.

A \emph{\textbf Context-\textbf Free \textbf Grammar}(CFG) is a formal description of a language.
A CFG~$G$ has three components:~$Ξ$ a set of \emph{variables} (also called nonterminals),
  a unique \emph{start variable}~$ξ∈Ξ$, and a finite set of (production) \emph{rules}.
A rule~$r∈G$ describes the derivation of a variable~$ξ∈Ξ$ into
  a string of \emph{symbols}, where symbols are either terminals or variables.
Accordingly, rule~$r∈G$ is written as~$r=ξ→β$, where~$β∈\left(Σ∪Ξ\right)^*$.
This description is often called BNF\@.
The \emph{language} of a CFG is the set of strings of terminals (and terminals only)
  that can be derived from the start symbol, following any sequence of applications of the rules.
CFG languages make a proper superset of regular languages, and a proper subset of 
  ‟context-sensitive” languages~\cite{Hopcroft:Ullman:01}.

The expressive power of NPDAs and BNFs is the same:
  For every language defined by a BNF, there exists a NPDA that recognizes it.
Conversely, there is a BNF definition for any language recognized by some NPDA.

NPDAs run in exponential deterministic time.
 A more sane, but weaker, alternative is found in LR($1$) parsers,
  which are deterministic linear time and space.
Such parsers employ a stack and a finite automaton structure,
  to parse the input.
 More generally, LR($k$) parsers,~$k>1$, can be defined. These make their
 decisions based on the next~$k$ input character, rather than just the first of these.
 General LR($k$) parsers are rarely used, since they offer essentially
 the same expressive power†{they recognize the same set of languages~\cite{Knuth:65}.},
 at a greater toll on resources (e.g., size of the automaton).
In fact, the expressive power of LR($k$),~$k\ge1$ parsers, is that
 of ‟\emph{\textbf Deterministic \textbf Pushdown \textbf Automaton}” (DPDA),
  which are similar to NPDA, except that their conduct is deterministic.

\begin{Definition}[Deterministic Pushdown Automaton]
  \label{Definition:DPDA}
  \slshape
  A \textit{deterministic pushdown automaton} (DPDA) is a quintuple~$⟨Q,Γ,q₀,A,δ⟩$
  where~$Q$ is a finite set of \emph{states},~$Γ$ is a finite
  \emph{set of elements},~$q₀∈Q$ is the initial state,
  and~$A⊆Q$ is the \emph{set of accepting states} while~$δ$ is
  the \emph{partial state transition function}~$δ:Q⨉Γ⨉(Σ∪❴ε❵)↛Q⨉Γ^*$.
  \par
  A DPDA begins its work in state~$q₀$ with a single designated stack element residing on the stack.
  At each step, the automaton examines: the current state~$q∈Q$, 
  the element~$γ∈Γ$ at the top of the stack, and~$σ$, the next input token, 
  Based on the values of these, it decides how to proceed:
  \begin{quote}
  \begin{enumerate}
    \item If~$q∈A$ and the input is exhausted, the automaton accepts the input and stops.
    \item Suppose that~$δ(q,γ,ε)≠⊥$ (in this case, the definition of a DPDA
          requires that~$δ(q,γ,σ')=⊥$ for all~$σ'∈Σ$), and let~$δ(q,γ,ε)=(q',ζ)$.
          Then the automaton pops~$γ$ and pushes the string of stack
          elements~$ζ∈Γ^*$ into the stack.
    \item If~$δ(q,γ,σ)=(q',ζ)$, then the same happens, but the automaton also
          irrevocably consumes the token~$σ$.
    \item If~$δ(q,γ,ε)=δ(q,γ,σ)=⊥$ the automaton rejects the input and stops.
  \end{enumerate}
  \end{quote}
\end{Definition}

A \emph{configuration} is the pair of the current state and the stack contents.
Configurations represent the complete information on the 
    state of an automaton at any given point during its computation.
A \emph{transition} of a DPDA takes it from one configuration to another.
Transitions which do not consume an input character are called~\emph{$ε$-transitions}.

As mentioned above, NPDA languages are the same as CFG languages.
Equivalently, \emph{DCFG languages} (deterministic context-free grammar languages)
  are context-free languages that are recognizable by a DPDA\@.
The set of DCFG languages is still a proper superset of regular languages,
  but a proper subset of CFG languages.
 
\section{Statement of the Main Result}
\label{section:result}
Let~$\textsf{java}$ be a function that translates a terminal~$σ∈Σ$
into a call to a uniquely named function (with respect to~$σ$).
Let~$\textsf{java}(α)$, be the function
  that translates a string~$α∈Σ^*$ into a fluent API call chain.
  If~$α=σ₁⋯σₙ∈Σ^*$, then \[
  \textsf{java}(α)=\textsf{java}(σ₁)\cc{().}⋯\cc{.}\textsf{java}(σₙ)\cc{()}
\]
For example, when~$Σ=❴a,b,c❵$ let~$\textsf{java}(a)=\cc{a}$,~$\textsf{java}(b)=\cc{b}$, and,~$\textsf{java}(c)=\cc{c}$.
With these, \[
    \textsf{java}(caba) = \cc{c().a().b().a()}
  \]

\begin{theorem}\label{Theorem:Gil-Levy}
  Let~$A$ be a DPDA recognizing a language~$L⊆Σ^*$.
  Then, there exists a \Java type definition,~$J_A$ for types~\cc{L},~\cc{A} and
    other types such that the \Java command
  \begin{equation}
    \label{Equation:result}
    \cc{L~$ℓ$ = A.build.$\textsf{java}(α)$}\cc{.\$();}
  \end{equation}
  type checks against~$J_A$ if an only if~$α∈L$.
  Furthermore, program~$J_A$ can be effectively generated from~$A$.
\end{theorem}

\Cref{Equation:result} reads: starting from the \kk{static} field \cc{build} of \kk{class}~\cc{A},
  apply the sequence of call chain~$\textsf{java}(α)$, terminate with a call to the
  ending character~\cc{\$()} and then assign to newly declared \Java variable~\cc{$ℓ$} of type~\cc{L}.

The proof of the theorem is by a scheme for encoding in \Java types
  the pushdown automaton~$A=A(L)$ that recognizes language~$L$.
Concretely, the scheme assigns a type~$τ(c)$
  to each possible configuration~$c$ of~$A$.
Also, the type of \cc{A.build} is~$τ(c₀)$, where~$c₀$ is the initial configuration of~$A$,

Further, in each such type the scheme places
  a function~$σ()$ for every~$σ∈Σ$.
Suppose that~$A$ takes a transition from configuration~$cᵢ$ to configuration~$cⱼ$
  in response to an input character~$σₖ$.
Then, the return type of function \cc{$σₖ$()} in type~$τ(cᵢ)$ is type~$τ(cⱼ)$.

With this encoding the call chain in \cref{Equation:result}
  mimics the computation of~$A$, starting at~$c₀$ and ending with
  rejection or acceptance.
The full proof is in \cref{section:proof}.

Since the depth of the stack is unbounded, the number of configurations of $A$ is unbounded,
  and the scheme must generate an infinite number of types.
Genericity makes this possible, since a generic type is
  actually device for creating an unbounded number of types.

There are several, mostly minor, differences between the structure of the \Java code
in \cref{Equation:result}
and the examples of fluent API we saw above\ReplaceInThesis{,e.g., in \cref{figure:DSL}}{}:
\begin{description}
  \item[Prefix, i.e., the starting \cc{A.build} variable.]
  All variables and functions of \Java are defined within a class.
  Therefore, a call chain must start with an object (\cc{A.build} in \cref{Equation:result})
  or, in case of \cc{static} methods, with the name of a class.
  In fluent API frameworks this prefix is typically eliminated
  with appropriate \cc{import} statements.
  \par
  If so desired, the same can be done by our type encoding scheme: define all
  methods in type~$τ(c₀)$ as \cc{static} and \cc{import static} these.
  \item[Suffix, i.e., the terminal \cc{.\$()} call.]
  In order to know whether~$α∈L$ the automaton recognizing~$L$ must
  know when~$α$ is terminated.
  \par
  With a bit of engineering, this suffix can also be eliminated.
  One way of doing so is by defining type~\cc{L} as an \kk{interface}, and by making all types~$τ(c)$,~$c$ is
  an accepting configuration, as subtype of~\cc{L}.
  \item[Parameterized methods.]
  Fluent API frameworks support call chains with phrases such as:
  \begin{itemize}
    \item ‟\lstinline{.when(header(foo).isEqualTo("bar")).}”,
    \item ‟\lstinline{.and(BOOK.PUBLISHED.gt(date("2008-01-01"))).}”, and,
    \item ‟\lstinline{.allowing(any(Object.class)).}”.
  \end{itemize}
  while our encoding scheme assumes methods with no parameters.  
  \par
    Methods with parameters contribute to the user
      experience and readability of fluent APIs but their ``computational expressive power"' is the same.
      In fact, extending
      \cref{Theorem:Gil-Levy} to support these requires these conceptually simple steps 
      \begin{enumerate}
        \item Define the structure of parameters to methods with appropriate fluent API, which may or
          may not be, the same as the fluent API of the outer chain, or the fluent API of parameters to
          other methods. Apply the theorem to each of these fluent APIs.
        \item
          If there are several overloaded versions of a method, consider each such version as a distinct
          character in the alphabet~$Σ$ and in the type encoding of the automaton.
        \item
          Add code to the implementation of each method code to store the 
          value of its argument(s) in a record placed at the end of the fluent-call-list. 
      \end{enumerate}
\end{description}
 
\section{Techniques of Type Encoding}
\label{section:toolkit}
This section presents techniques and idioms of type encoding in \Java 
  partly to serve in the proof of \Cref{Theorem:Gil-Levy}, 
  and partly to familiarize the reader with 
  the challenges of type encoding. 

Let~$g:Γ↛Γ$ be a partial function,
  from the finite set~$Γ$ into itself.
We argue that~$g$ can
  be represented using the compile-time mechanism of \Java.
  \cref{Figure:unary-function\ReplaceInThesis{}{-b}} encodes such a partial function for~$Γ=❴γ₁,γ₂❵$, where~$g(γ₁)=γ₂$
  and~$g(γ₂)=⊥$, i.e.,~$g(γ₂)$ is undefined.†{Unless otherwise stated,
      all code excerpts here represent full implementations,
      and automatically extracted, omitting headers and footers,
    from \Java programs that compile correctly with a \Java 8 compiler.}

\ReplaceInThesis{\begin{figure}[hbt]
  \caption[Type encoding of partial unary function]{\label{Figure:unary-function}    Type encoding of partial function~$g:Γ↛Γ$,
    defined by~$Γ=❴γ₁,γ₂❵$,~$g(γ₁)=γ₂$ and~$g(γ₂)=⊥$.
  }
  \begin{tabular}{@{}c@{}c@{}c@{}}
    \hspace{-7ex}
    \parbox[c]{0.26\linewidth}{      \begin{tikzpicture}
\usetikzlibrary{calc}
\tikzstyle{concept}=[,text=red!50,font=,  text centered, rectangle,inner sep=4pt,fill=yellow!50,outer sep=2pt,minimum height=3ex,minimum width=7ex,rectangle ,rounded corners,level distance=10ex]
\graph [tree layout] {"\cc{$\Gamma'$}"[concept],
"\cc{$\Gamma'.\Gamma$}"[concept],
"\cc{$\Gamma'$.\currency}"[concept],
"\cc{$\Gamma'.\Gamma.\gamma1$}"[concept],
"\cc{$\Gamma'.\Gamma.\gamma2$}"[concept],
{{"\cc{$\Gamma'.\Gamma.\gamma1$}",  
"\cc{$\Gamma'.\Gamma.\gamma2$}",  
} -> "\cc{$\Gamma'.\Gamma$}",
"\cc{$\Gamma'$.\currency}"}-> 
	"\cc{$\Gamma'$}", 
};
\end{tikzpicture}
     }    &
    \hspace{-1ex}
    \parbox[c]{0.64\linewidth}{      \javaInput[]{gamma.listing}
    }    &
    \hspace{-18ex}
    \parbox[c]{0.84\linewidth}{      \javaInput[,toprule=3pt,leftrule=3pt,bottomrule=3pt]{gamma-example.listing}
    }⏎
\textbf{(a)} type hierarchy & \textbf{(b)} implementation & \hspace{-62ex} \textbf{(c)} use cases
  \end{tabular}
\end{figure}
}{\begin{figure}[hbt]
  \caption[Type hierarchy of partial unary function]{\label{Figure:unary-function-a}    Type hierarchy of partial function~$g:Γ↛Γ$,
    defined by~$Γ=❴γ₁,γ₂❵$,~$g(γ₁)=γ₂$ and~$g(γ₂)=⊥$.
  }\centering
      \begin{tikzpicture}
\usetikzlibrary{calc}
\tikzstyle{concept}=[,text=red!50,font=,  text centered, rectangle,inner sep=4pt,fill=yellow!50,outer sep=2pt,minimum height=3ex,minimum width=7ex,rectangle ,rounded corners,level distance=10ex]
\graph [tree layout] {"\cc{$\Gamma'$}"[concept],
"\cc{$\Gamma'.\Gamma$}"[concept],
"\cc{$\Gamma'$.\currency}"[concept],
"\cc{$\Gamma'.\Gamma.\gamma1$}"[concept],
"\cc{$\Gamma'.\Gamma.\gamma2$}"[concept],
{{"\cc{$\Gamma'.\Gamma.\gamma1$}",  
"\cc{$\Gamma'.\Gamma.\gamma2$}",  
} -> "\cc{$\Gamma'.\Gamma$}",
"\cc{$\Gamma'$.\currency}"}-> 
	"\cc{$\Gamma'$}", 
};
\end{tikzpicture}
 \end{figure}
\begin{figure}[hbt]
  \caption[Type encoding of partial unary function]{    Type encoding of partial function defined in \cref{Figure:unary-function-a}
  }
  \label{Figure:unary-function-b}      \javaInput[minipage,width=\linewidth]{gamma.listing}
\end{figure}
\begin{figure}[hbt]
  \caption[Use cases of partial unary function]{    Use cases of partial function defined in \cref{Figure:unary-function-a}
  }
  \label{Figure:unary-function-c}      \javaInput[minipage,width=\linewidth]{gamma-example.listing}
\end{figure}
}

The type hierarchy depicted in~\cref{Figure:unary-function\ReplaceInThesis{}{-a}}\ReplaceInThesis{(a)}{} shows five classes:
Abstract class~\cc{Γ}~†{Remember that \Java admits Unicode characters in identifier names} represents the set~$Γ$, final classes~\cc{γ1},~\cc{γ2}
  that extend~\cc{$Γ$}, represent the actual members of the set~$Γ$.
The remaining two classes are private final class~\cc{¤} that stands for an error value,
  and abstract class~\cc{$Γ'$} that denotes the augmented set~$Γ∪❴\text{¤}❵$.
Accordingly, both classes~\cc{¤} and~\cc{$Γ$} extend~\cc{$Γ'$}.†{The use
  of short names, e.g.,~\cc{$Γ$} instead of \cc{$Γ'.Γ$},
    is made possible by an appropriate \kk{import} statement omitted here and henceforth.}

    The full implementation of these classes is provided in~\cref{Figure:unary-function\ReplaceInThesis{}{-b}}\ReplaceInThesis{(b)}{}.
This actual code excerpt should be placed as a nested class of some appropriate host class. Import statements are omitted, here and henceforth for brevity.

The use cases in~\cref{Figure:unary-function\ReplaceInThesis{}{-c}}\ReplaceInThesis{(c)}{} explain better
  what we mean in saying that function~$g$ is encoded in the type system:
  An instance of class~\cc{$γ$1} returns a value of type~\cc{$γ$2} upon
  method call~\cc{g()}, while
  an instance of class~\cc{$γ$2} returns a value of our~\kk{private}
  error type~\cc{$Γ'$.¤} upon the same call.

Three recurring idioms employed in~\cref{Figure:unary-function\ReplaceInThesis{}{-b}}\ReplaceInThesis{(b)}{} are:
\begin{enumerate}
  \item An~\kk{abstract} class encodes a set (alternatively, one can use \kk{interface}s).
    Abstract classes that extend it encode
      subsets, while~\kk{final} classes encode set members.
  \item The interest of frugal management of name-spaces is served
    by the agreement that if a class~\cc{$X$}~\kk{extends} another class~\cc{$Y$}, then~\cc{$X$} is also defined
    as a~\kk{static} member class of~$Y$.
  \item Bodies of functions are limited to a single~\kk{return}~\kk{null}\cc{;} command
      (with interfaces the method body is redundant).
      This is to stress that at runtime, the code does not carry out any useful or interesting computation,
      and the class structure is solely for providing compile-time type checks.
†{A consequence of these idioms is that the augmented class~\cc{$Γ'$} is visible to clients.
It can be made~\cc{private}. Just move class~\cc{$Γ$} to outside of~\cc{$Γ'$}, defying the second idiom.
}
\end{enumerate}

Having seen how inheritance and overriding make possible
  the encoding of unary functions, we turn now to encoding higher arity functions.
With the absence of multi-methods, other techniques must be used.

Consider the partial binary function~$f: R⨉S↛Γ$, defined by
\begin{equation}
  \label{Equation:simple-binary}
  \begin{array}{*3c}
    R=❴r₁,r₂❵ & f(r₁,s₁)=γ₁ & f(r₂,s₁)=γ₁⏎
    S=❴s₁,s₂❵ & f(r₁,s₂)=γ₂ & f(r₂, s₂)=⊥
  \end{array}.
\end{equation}
A \Java type encoding of this definition of function~$f$
is in~\cref{Figure:simple-binary\ReplaceInThesis{}{-a}}\ReplaceInThesis{(a)}{}; use cases
are in~\cref{Figure:simple-binary\ReplaceInThesis{}{-b}}\ReplaceInThesis{(b)}{}.

\ReplaceInThesis{\begin{figure}[hbt]
  \caption[Type encoding of partial binary function]{\label{Figure:simple-binary}    Type encoding of partial binary function~$f:R⨉S↛Γ$,
    where~$R=❴r₁,r₂❵$,~$S=❴s₁,s₂❵$, and~$f$
    is specified by~$f(r₁,s₁)=γ₁$,~$f(r₁,s₂)=γ₂$,~$f(r₂,s₁)=γ₁$, and~$f(r₂, s₂)=⊥$.}
  \begin{tabular}{cc}
    \hspace{-3.5ex}
    \parbox[c]{0.57\linewidth}{    \javaInput[]{binary-function.listing}
    }
      &
    \hspace{-16ex}
    \parbox[c]{51ex}{\javaInput[minipage,leftrule=3pt,toprule=3pt,bottomrule=3pt,width=51ex]{binary-function-example.listing}}
⏎
    \parbox{0.57\linewidth}
    {\textbf{(a)} implementation (except for classes~\cc{$Γ$},~\cc{$Γ'$},~\cc{$γ$1}, and~\cc{$γ$2},
    found in \cref{Figure:unary-function}).}
      & \hspace{-5ex}\textbf{(b)} use cases⏎
  \end{tabular}
\end{figure}
}{\begin{figure}[hbt]
  \caption[Type encoding of partial binary function]{    Type encoding of partial binary function~$f:R⨉S↛Γ$,
    where~$R=❴r₁,r₂❵$,~$S=❴s₁,s₂❵$, and~$f$
    is specified by~$f(r₁,s₁)=γ₁$,~$f(r₁,s₂)=γ₂$,~$f(r₂,s₁)=γ₁$, and~$f(r₂, s₂)=⊥$
     (except for classes~\cc{$Γ$},~\cc{$Γ'$},~\cc{$γ$1}, and~\cc{$γ$2},
    found in \cref{Figure:unary-function-b}) }
    \label{Figure:simple-binary-a}    \javaInput[minipage,width=\linewidth]{binary-function.listing}
\end{figure}
\begin{figure}[hbt]
  \caption[Use cases of partial binary function]{    Use cases of partial binary function defined in \cref{Figure:simple-binary-a} 
  }
    \label{Figure:simple-binary-b}
    \javaInput[minipage,left=-2ex,width=\linewidth]{binary-function-example.listing}
\end{figure}
}

As the figure shows, to compute~$f(r₁,s₁)$ at compile time we write~\cc{f.r1().s1()}.
Also, the fluent API call chain~\cc{f.r2().s2().g()} results in a compile time
error because 
\[
    f(r₂, s₂)=⊥.
\]

Class~\cc{f} in the implementation sub-figure serves as
  the starting point of the little fluent API defined here.
The return type of~\kk{static} member functions~\cc{r1()} and~\cc{r2()}
  is the respective sub-class of class~\cc{R}:
The return type of function~\cc{r1()} is class~\cc{R.r1};
  the return type of function~\cc{r2()} is class~\cc{R.r2}.

Instead of representing set~$S$ as a class,
  its members are realized as methods~\cc{s1()} and~\cc{s2()} in class~\cc{R}.
These functions are defined as~\kk{abstract} with return type~\cc{$Γ$'}
  in~\cc{R}.
Both functions are overridden in classes~\cc{r1} and~\cc{r2},
   with the appropriate covariant change of their return type,

It should be clear now that the encoding scheme presented
in \Cref{Figure:simple-binary\ReplaceInThesis{}{-a}} can be generalized to functions
  with any number of arguments, provided that the domain and range sets are finite.
The encoding of sets of unbounded size require means for creating an unbounded
 number of types.
Genericity can be employed to serve this end.

\ReplaceInThesis{\begin{wrapfigure}[8]{r}{31ex}
  \intextsep=0pt
  \caption{\label{Figure:id}  Covariant return type of function \cc{id()}
  with \Java generics.
  }
  \javaInput[,minipage,width=31ex]{id.listing}
\end{wrapfigure}
}{\begin{figure}[ht]
  \caption{\label{Figure:id}    Covariant return type of function \cc{id()}
    with \Java generics.  }
  \javaInput[minipage,left=-2ex,width=\linewidth]{id.listing}
\end{figure}
}

\Cref{Figure:id} shows a genericity based recipe for
  a function whose return type
  is the same as the receiver's type.
  This recipe is applied in the figure to classes~\cc{A},~\cc{B}, and~\cc{C}.
  In each of these classes, the return type of \cc{id} is,
  without overriding, (at least) the class itself.

It is also possible to encode with \Java generic types
  unbounded data structures, 
  as demonstrated in \cref{Figure:stack-use-cases},
  featuring a use case of a stack of an \emph{unbounded} depth.
\vspace{2ex}

\begin{figure}[ht]
  \caption{\label{Figure:stack-use-cases}    Use cases of a compile-time stack data structure.
  }
  \javaInput[minipage,,listing style=numbered]{stack-use-cases.listing}
\end{figure}

In line 3 of the figure, a stack with five elements is created:
These are popped in order (ll.4--7,l.9).
Just before popping the last item, its value is examined (l.8).
Trying then to pop from an empty stack (l.10), or to examine its top (l.11), ends with
  a compile time error.

Stack elements may be drawn from some abstract set~$Γ$.
In the figure these are either class~\cc{$γ$1}
or class \cc{$γ$2} (both defined in \cref{Figure:unary-function\ReplaceInThesis{}{-b}}).
A call to function \cc{$γ$}$i$ pushes the type \cc{$γ$}$i$
  into the stack, for~$i=1,$.
The expression
\[
  \cc{Stack.empty.$γ$1().$γ$1().$γ$2().$γ$1().$γ$1()}
\]
represents the sequence of pushing the value~$γ₁$ into an
empty stack, followed by~$γ₁$,~$γ₂$,~$γ₁$, and, finally,~$γ₁$.
This expression's type is that of variable~\cc{\_1}, i.e.,⏎
\[
 \cc{P<$γ$1,P<$γ$1,P<$γ$2,P<$γ$1,P<$γ$1,E>>>>>}
\]

A recurring building block occurs in this type: 
  generic type~\cc{P}, \emph{short for ‟Push”}, which takes two parameters:
  \begin{enumerate}
    \item the \emph{top} of the stack, always a subtype of~\cc{$Γ$},
    \item the \emph{rest} of the stack, which can be of two kinds:
          \begin{enumerate}
            \item another instantiation of~\cc{P} (in most cases),
            \item non-generic type~\cc{E}, \emph{short for ‟Empty”}, which encodes the empty
              stack. Note that \cc{E} can only occur at the deepest~\cc{P}, encoding a stack 
              with one element, in which the rest is empty. 
          \end{enumerate}   \end{enumerate}
Incidentally, \kk{static} field \cc{Stack.empty} is of type~\cc{E}.

\Cref{Figure:stack-encoding\ReplaceInThesis{}{-a}}\ReplaceInThesis{(a)}{} gives the type inheritance hierarchy 
of type \cc{Stack} and its subtypes.
\Cref{Figure:stack-encoding\ReplaceInThesis{}{-b}}\ReplaceInThesis{(b)}{}
gives the implementation of these types.
\ReplaceInThesis{\begin{figure}[!htb]
  \caption{Type encoding of an unbounded stack data structure}
  \label{Figure:stack-encoding}
  \begin{tabular}{cc}
    \parbox[c]{0.3\linewidth}{      \begin{tikzpicture}
\usetikzlibrary{calc}
\tikzstyle{concept}=[,text=red!50,font=,  text centered, rectangle,inner sep=4pt,fill=yellow!50,outer sep=2pt,minimum height=4ex,minimum width=8ex,rectangle ,rounded corners]
\graph [tree layout] {	"\cc{Stack<Rest>}"[nudge=(up:2ex),concept], 
	"\cc{Stack.E}"[nudge=(right:11ex),yshift=1ex,concept], 
	"\cc{Stack.P<Top,Rest>}"[nudge=(left:5ex),yshift=-13ex,concept], 
	"\cc{Stack.\currency}"[nudge=(left:16ex),yshift=-7ex,concept], 
  {"\cc{Stack.E}","\cc{Stack.P<Top,Rest>}",  "\cc{Stack.\currency}", } ->"\cc{Stack<Rest>}",
};
\end{tikzpicture}
     } &
    \hspace{-3ex} \parbox[c]{63ex}{\javaInput[minipage,]{stack.listing}}⏎
    \textbf{(a)} type hierarchy &
    \hspace{-3ex} \parbox[t]{63ex}{    \textbf{(b)} implementation (except
    for classes~\cc{$Γ$},~\cc{$Γ'$},~\cc{$γ$1}, and~\cc{$γ$2}, which is in \cref{Figure:unary-function}).}
  \end{tabular}
\end{figure}
}{\begin{figure}[ht]
  \caption{Type hierarchy of an unbounded stack data structure}
  \label{Figure:stack-encoding-a}
    \centering  \begin{tikzpicture}
\usetikzlibrary{calc}
\tikzstyle{concept}=[,text=red!50,font=,  text centered, rectangle,inner sep=4pt,fill=yellow!50,outer sep=2pt,minimum height=4ex,minimum width=8ex,rectangle ,rounded corners]
\graph [tree layout] {	"\cc{Stack<Rest>}"[nudge=(up:2ex),concept], 
	"\cc{Stack.E}"[nudge=(right:11ex),yshift=1ex,concept], 
	"\cc{Stack.P<Top,Rest>}"[nudge=(left:5ex),yshift=-13ex,concept], 
	"\cc{Stack.\currency}"[nudge=(left:16ex),yshift=-7ex,concept], 
  {"\cc{Stack.E}","\cc{Stack.P<Top,Rest>}",  "\cc{Stack.\currency}", } ->"\cc{Stack<Rest>}",
};
\end{tikzpicture}
 \end{figure}
\begin{figure}[ht]
  \caption[Type encoding of an unbounded stack data structure]
    {Type encoding of an unbounded stack data structure (except
    for classes~\cc{$Γ$},~\cc{$Γ'$},~\cc{$γ$1}, and~\cc{$γ$2},
    which is in \cref{Figure:unary-function-b})}
  \label{Figure:stack-encoding-b}
    \javaInput[minipage,left=-3ex,width=\linewidth]{stack.listing}
\end{figure}
}
The code in the figure shows that the ‟rest” parameter of~\cc{P} must extend class \cc{Stack},
  and that both types~\cc{P} and~\cc{E} extend \cc{Stack}.
Other points to notice are:
\begin{itemize}
  \item The type at the top of the stack is precisely the return type of \cc{top()};
        it is overridden in~\cc{P} so that its return type is the first argument of~\cc{P}.
        The return type of \cc{top()} in~\cc{E} is the error value {$Γ'$.¤}.
  \item Pushing into the stack is encoded as functions~\cc{$γ$1()} and~\cc{$γ$2()};
        the two are overridden with appropriate covariant change of the return type in~\cc{P} and~\cc{E}.
  \item Since an empty stack cannot be popped, function \cc{pop()} is overridden in~\cc{E} to return
    the \emph{error} type \cc{Stack.¤}. This type is indeed a kind of a stack, except that each of the four stack
        functions: \cc{top()}, \cc{push()},~\cc{$γ$1()}, and,~\cc{$γ$2()}, return an appropriate error type.
\end{itemize}
In fact, this recursive generic type technique can used to encode S-expressions: In the spirit of
  \cref{Figure:stack-encoding\ReplaceInThesis{}{-b}}, the idea is to make use of a \cc{Cons} generic type
  with covariant \cc{car()} and \cc{cdr()} methods.

A standard technique of template programming in \CC is to encode conditionals with template specialization.
Since \Java forbids specialization of generics, in lieu we use covariant overloading of function
return type (e.g., the return type of \cc{s2()} in \cref{Figure:simple-binary\ReplaceInThesis{}{-a}} and the
  return type of \cc{top()} in \cref{Figure:stack-encoding\ReplaceInThesis{}{-b}}).

\ReplaceInThesis{\begin{wrapfigure}[6]r{38ex}
  \caption{\label{Figure:generic} Covariance of parameters to generics}
  \javaInput[minipage,]{mammal.listing}
\end{wrapfigure}
}{  \begin{figure}[ht]
  \caption{\label{Figure:generic} Covariance of parameters to generics}
\javaInput[minipage,left=-2ex,width=\linewidth]{mammal.listing}
\end{figure}
}
\cref{Figure:generic} shows that a similar covariant change is possible 
  in extending a generic type.
The type of the parameter \cc{M} 
  to \cc{Heap} is ``\mbox{\cc{?} \kk{extends} \cc{Mammals}}''.
This type is specialized as \cc{School} extends \cc{Heap}:
  parameter \cc{W} of \cc{School} is of type  
  ``\mbox{\cc{?} \kk{extends} \cc{Whales}}''.
Covariant specialization of parameters to generics 
  is yet another idiom for encoding conditionals.

Overloading gives rise to a third idiom for partial emulation of conditionals, as can be seen
  in~\cref{Figure:peep}.

\begin{figure}[htb]  \caption{Peeping into the stack}  \label{Figure:peep}  \lstset{style=numbered}
  \javaInput[minipage,]{peep.listing}
\end{figure}

The figure depicts type \cc{Peep} and overloaded versions of \cc{peep()} which 
      together make it possible to extract the top of the stack.
The first generic parameter to \cc{Peep} is the top of the stack, the second is the stack itself.
Indeed, we see (l.11) that peeping into an empty stack, places a~\cc{?}
  in the first parameter, thanks to the first overloaded version of \cc{peep()} (l.2).

The second overloaded version of \cc{peep()} (ll.3--6) matches
 against all non-empty stacks. 
The return type
 of this version encodes
 in its first parameter
 the top of the stack, and 
  in its second parameter, the parameter's type.
A use case is in line~9.

Let~$τ$ be the type of the top of a given stack.
Then, both \cc{top()} and \cc{peep()} can be used to extract~$τ$.
There is a subtle difference between the two though:
Obtaining~$τ$ from \cc{top()} does
  not make it possible to define variables, function return types, and
  parameters to functions and generics whose type is~$τ$ or depends on it in any way.
However, since \cc{Peep} is a type that receives~$τ$ as parameter,
  the body of \cc{Peep} is free to define e.g., functions signature includes on~$τ$,
  or pass~$τ$ further to other generics.
 
\section{The Jump-Stack Data-Structure}
\label{section:jump}
\ReplaceInThesis{\begin{wrapfigure}[19]{r}{44ex}
  \caption{Skeleton of type encoding for the jump-stack data structure}  \label{Figure:jump}  \javaInput[minipage,listing style=numbered]{jump-stack.listing}
\end{wrapfigure}
}{  \begin{figure}[ht]
  \caption{Skeleton of type encoding for the jump-stack data structure}  \label{Figure:jump}  \javaInput[minipage,listing style=numbered,width=\linewidth]{jump-stack.listing}
\end{figure}
}
A \emph{jump-stack} is a stack data structure whose elements are drawn from a finite set~$Γ$,
  except that jump-stack supports~$\textsf{jump}(γ)$,~$γ∈Γ$ operations
  (which means ‟repetitively \emph{pop} elements from the stack up
  to and including the first occurrence of~$γ$”).

\Cref{Figure:jump} shows the skeleton of type-encoding, in parameterized type \cc{JS},
  of a jump-stack whose elements are drawn from type~\cc{$Γ$}
  (\ReplaceInThesis{\cref{Figure:unary-function}(b)}{\cref{Figure:unary-function-b}}), i.e., either~\cc{$γ$1} or~\cc{$γ$2}.

Just like \cc{Stack} (\cref{Figure:stack-encoding\ReplaceInThesis{}{-b}}\ReplaceInThesis{(b)}{}), \cc{JS} takes
  a \cc{Rest} parameter encoding the type of a jump-stack after popping.
In addition \cc{JS} takes~$k=|Γ|$ type parameters, one for each~$γ∈Γ$,
  which is the type encoding of the jump-stack after a~$\textsf{jump}(γ)$
  operation.
In the figure, there are two such parameters: \cc{J\_$γ$1}, and
  \cc{J\_$γ$2}.

Functions defined in \cc{JS} include not only the standard stack operations: \cc{top()},
\cc{pop()}, \cc{$γ1$()} and~\cc{$γ2$()} (encoding a push of~$γᵢ$,~$i=1,2$, in general, there are~$k$),
but also~$k$ functions encoding~$\textsf{jump}(γ)$,~$γ∈Γ$.
In our case, these are \cc{jump\_$γ$1} and \cc{jump\_$γ$2},
  which encode~$\textsf{jump}(γᵢ)$
  thanks to their return type being~\cc{J\_$γ${}$i$},~$i=1,2$.

The type hierarchy rooted at \cc{JS} is similar to that of
\cref{Figure:stack-encoding\ReplaceInThesis{}{-a}}\ReplaceInThesis{(a)}{}:
Two of the specializations are parameter-less and are
  almost identical to their \cc{Stack}
  counterparts:
\cc{JS.E} encodes an empty jump-stack; \cc{JS.¤} encodes a jump-stack in error,
e.g., after popping from \cc{JS.E}.
The body of these two types is omitted here.

\ReplaceInThesis{\begin{wrapfigure}[11]r{31ex}
  \caption{\label{Figure:jump-stack-push} Auxiliary type~\cc{Pʹ} encoding succinctly a non-empty jump-stack}
  \javaInput[minipage,width=31ex,listing style=numbered]{jump-stack-push.listing}
\end{wrapfigure}
}{  \begin{figure}[ht]
  \caption{\label{Figure:jump-stack-push} Auxiliary type~\cc{Pʹ} encoding succinctly a non-empty jump-stack}
  \javaInput[minipage,width=\linewidth,listing style=numbered]{jump-stack-push.listing}
\end{figure}
}
Type \cc{JS.P} (lines 16--23 in \cref{Figure:jump}) makes the third specialization of \cc{JS}, encoding
  a stack with one or more elements.
Just like in \cref{Figure:id}, there are no overridden functions in \cc{JS.P}; it fulfills
  its duties through the type parameters it takes and the types it passes
  to~\cc{Pʹ} the generic type it extends.

Specifically, \cc{JS.P} takes
the same \cc{Top} and \cc{Rest} parameters (ll.17--18) as type \cc{Stack.P}:
  as well as~$k$ additional parameters:
  \cc{J\_$γ$1} and \cc{J\_$γ$2} (ll.19--20)
which are the types encoding the jump-stack
  after the execution~$\textsf{jump}(γᵢ)$,~$i=1,2$.
Type \cc{JP.P} passes these four parameters
to type \cc{Pʹ} which it extends (l.21).
The fifth parameter to \cc{Pʹ} (l.22) is the current incarnation of~\cc{P}, i.e.,
  \cc{P<Top, Rest, J\_γ1, J\_γ2>}.

The auxiliary (and \kk{private}) type \cc{Pʹ} itself is depicted in \cref{Figure:jump-stack-push}.
By extending type \cc{JS} and passing the correct \cc{Rest} (respectively, \cc{J\_$γ$1}, \cc{J\_$γ$2})
parameter to it, \cc{Pʹ} inherits correct declaration of function \cc{pop()} (l.8~\cref{Figure:jump})
  (respectively \cc{jump\_$γ$1} (l.11 ibid), \cc{jump\_$γ$2} (l.12 ibid)).

More importantly, the \cc{Me} type parameter to \cc{Pʹ} represents type \cc{JP.P}
  that extends \cc{Pʹ}.
Type \cc{Me} also captures the actual parameters \emph{included} to \cc{JP.P},
  which makes it possible to write the return type of \cc{$γ$1()} and \cc{$γ$2()} more succinctly.
Let, e.g.,~$τ=\cc{P<γ1, Me, Me, J\_γ2>}$ be the return type of \cc{$γ$1()}.
The first two parameters to~$τ$ say that pushing~\cc{$γ$1},
  results in a compound jump-stack, whose top element is \cc{$γ$1},
  and where the rest of the jump-stack is the current type.
The third parameter to~$τ$ says that since \cc{$γ$1} was pushed the result
  of a~$\textsf{jump}(γ₁)$ is the type of the receiver.
The fourth parameter is \cc{J\_$γ$2} since a push of~$γ₁$ does not
  change the result of~$\textsf{jump}(γ_2)$.

\ReplaceInThesis{\begin{wrapfigure}[12]r{42ex}
  \caption{\label{Figure:jump-stack-example} Use cases for the~\cc{JS} type hierarchy}
  \javaInput[minipage,width=42ex,left=-2ex]{jump-stack-example.listing}
\end{wrapfigure}
}{  \begin{figure}[ht]
  \caption{\label{Figure:jump-stack-example} Use cases for the~\cc{JS} type hierarchy}
  \javaInput[minipage,width=\linewidth,left=-2ex]{jump-stack-example.listing}
\end{figure}
}

Some use cases for the encoded jump-stack data structure are in \cref{Figure:jump-stack-example}.
The type of variable \cc{\_1} encodes a stack into which \cc{$γ$2}, \cc{$γ$1}, \cc{$γ$1} were pushed
  (in this order).
Examining the type of \cc{\_2} we see that executing \cc{jump\_$γ$2} on
  \cc{\_1}, yields the empty stack in a single step.
The type of \cc{\_3} is that state of the same stack
  after executing~\cc{jump\_$γ$1};
  it is exactly the same as popping a single element from the stack.
 
\section{Proof of \Cref{Theorem:Gil-Levy}}
\label{section:proof}
On a first sight, the proof of \cref{Theorem:Gil-Levy} could follow the techniques
  sketched in \cref{section:toolkit} to type encode a DPDA (\cref{Definition:DPDA}).
  The partial transition function~$δ$ may be type encoded as in \ReplaceInThesis{\cref{Figure:simple-binary}(a)}{\cref{Figure:simple-binary-a}},
and the stack data structure of a DPDA can be encoded as in \cref{Figure:stack-encoding\ReplaceInThesis{}{-b}}.

The techniques however fail with~$ε$-transitions,
  which allow the automaton to move between an unbounded number of
  configurations and maneuver the stack in a non-trivial manner,
  without making any progress on the input.
The fault in the scheme lies with compile time computation being carried out
  by the~$\textsf{java}(σ)()$ functions, each converting
  their receiver type to the type of the receiver of the next call in the chain.
We are not aware of a \Java type encoding which makes
  it possible to convert an input type into an output type, where
  the output is computed from the input by an unbounded number of steps.
  †{With the presumption that the \Java compiler halts for all inputs (a presumption that does
    not hold for e.g., \CC, and was never proved for \Java), the claim that there is no \Java 
    type encoding for all DPDAs can be proved:
    Employing~$ε$-transitions, it is easy to construct an automaton~$A^∞$ that
    never halts on any input.
    A type encoding of~$A^∞$ creates programs that send the compiler in an infinite loop.
  }

The literature speaks of finite-delay DPDAs, in which the number
  of consecutive~$ε$-transitions is uniformly bounded and even of
  realtime DPDAs in which this bound is 0, i.e., no~$ε$-transitions.
Our proof relies on a special kind of realtime automata,
  described by Courcelle~\cite{Courcelle:77}.

\begin{Definition}[Simple-Jump Single-State Realtime Deterministic Pushdown Automaton]
  \label{Definition:JDPDA}
  \slshape
  A \textit{simple-jump, single-state, realtime deterministic pushdown automaton}
  (jDPDA, for short) is a triplet~$⟨Γ,γ₁,δ⟩$
  where~$Γ$ is a set of stack elements,~$γ₁∈Γ$ is the initial stack element,
  and~$δ$ is the \emph{partial transition function},~$δ:Γ⨉Σ↛Γ^*∪j(Γ)$,
  \[
    j(Γ) = ❴ \textit{instruction \textup{\textsf{jump}}}(γ) \; | \;γ∈Γ❵.
  \]
  A configuration of a jDPDA is some~$c∈Γ^*$ representing the stack contents.
  Initially, the stack holds~$γ₁$ only.
  For technical reasons, assume that the input terminates with~$\$ \not∈Σ$, a special end-of-file character.
  \begin{itemize}
    \item At each step a jDPDA examines~$γ$,
    the element at the top of the stack,
    and~$σ∈Σ$, the next input character,
    and executes the following:
          \begin{quote}
            \begin{enumerate}
              \item consume~$σ$
              \item if~$δ(γ,σ)=ζ$,~$ζ∈Γ^*$, the automaton pops~$γ$, and pushes~$ζ$ into the stack.
              \item if~$δ(γ,σ)=\textsf{jump}(γ')$,~$γ'∈Γ$, then the automaton repetitively
                    pops stack elements up-to and including the first occurrence of~$γ'$.
            \end{enumerate}
          \end{quote}
    \item If the next character is~$\$$, the automaton may reject or accept (but nothing else),
          depending on the value of~$γ$.
  \end{itemize}
  In addition, the automaton rejects if~$δ(γ,σ) =⊥$ (i.e., undefined), or if it encounters
  an empty stack (either at the beginning of a step or on course of a \textsf{jump operation}).
\end{Definition}

\ReplaceInThesis{\begin{wraptable}r{36ex}
  \caption[Transition function of a jDPDA]
  {\label{Table:A} The transition function of a jDPDA~$A$,~$Σ=❴σ₁,σ₂,σ₃❵$,~$Γ=❴γ₁,γ₂❵$ where~$γ₁$ is the initial element}
  \begin{tabular}{c|ll}
  & \hfill~$γ₁$ & \hfill~$γ₂$⏎
    \midrule
$σ₁$ & $\textsf{push}(γ₁,γ₁,γ₂)$ & $\textsf{push}(γ₂,γ₂)$⏎
$σ₂$ & \hfill$⊥$ & $\textsf{push}(ε)$⏎
$σ₃$ & \hfill$⊥$ & $\textsf{jump}(γ₁)$⏎
$\$$ & \hfill$\textsf{accept}$ & $\textsf{reject}$⏎
  \end{tabular}
\end{wraptable}
}{  \begin{table}[ht]
  \caption[Transition function of a jDPDA]
  {\label{Table:A} The transition function of a jDPDA~$A$,~$Σ=❴σ₁,σ₂,σ₃❵$,~$Γ=❴γ₁,γ₂❵$ where~$γ₁$ is the initial element}
  \centering
  \begin{tabular}{c|ll}
  & \hfill~$γ₁$ & \hfill~$γ₂$⏎
    \midrule
$σ₁$ & $\textsf{push}(γ₁,γ₁,γ₂)$ & $\textsf{push}(γ₂,γ₂)$⏎
$σ₂$ & \hfill$⊥$ & $\textsf{push}(ε)$⏎
$σ₃$ & \hfill$⊥$ & $\textsf{jump}(γ₁)$⏎
$\$$ & \hfill$\textsf{accept}$ & $\textsf{reject}$⏎
  \end{tabular}
\end{table}
}
As it turns out, every DCFG language is recognized by some jDPDA, and conversely,
  every language accepted by a jDPDA is a DCFG language~\cite{Courcelle:77}.
The proof of \cref{Theorem:Gil-Levy} is therefore reduced to type-encoding of a given jDPDA\@.
Towards this end, we employ the type-encoding techniques developed above, and, 
  in particular, the jump-stack data structure (\cref{Figure:jump}).

Henceforth, let~$k =|Γ|$,~$ℓ=|Σ|$.
The simple~$k=2$,~$ℓ=3$ jDPDA~$A$ defined in \cref{Table:A} will serve as our running example.
Let~$L$ be the language recognized by~$A$.†{  Incidentally,
\[
  L = \left❴ w^* \; | \; w=\left(σ₁^{n}σ₂^{m}σ₃|σ₁^{n}σ₂^{n}\right) \; , \; n>m,n>1\right❵
\]
which is clearly not-regular; the equivalent BNF for~$L$ is:
\[
  S→W S		\,| \, ε	\; ; \; 
  W→D		\,| \, A Dσ₃ 	\; ; \;
  D→σ₁Dσ₂	\,| \, σ₁σ₂ 	\; ; \;
  A→Aσ₁		\,| \, σ₁ 	
\]

Neither the BNF nor the representation are material for the proof.
}

\subsection{Main Types}
Generation of a type encoding for a jDPDA starts with two empty types for sets~$L$,~$Σ^*$,
  where~$L$ represents the languages accepted by the jDPDA and~$Σ^*$ represents all words:
\begin{quote}
  \javaInput[minipage,width=\ReplaceInThesis{53ex}{\linewidth},left=-2ex]{proof.headers.listing}
\end{quote}
(The full type encoding is in \cref{Figure:A} below; to streamline the reading, we bring
  excerpts as necessary.)

A configuration is encoded by a generic type~\cc{C}.
Essentially,~\cc{C} is a representation of the stack,
  but~$k+1$ type parameters are required:
\begin{itemize}
  \item \cc{Rest}, a type encoding of the stack after a pop (or \textsf{jump} with the top element), and,
  \item $k$ types, named \cc{JR$γ$1}, … ,\cc{JR$γ${}$k$}, encoding the type of \cc{Rest}
    after~$\textsf{jump}(γ₁)$,…~$\textsf{jump}(γₖ)$.
\end{itemize}

Note that these~$k+1$ parameters are sufficient for describing a configuration,
  i.e., if the top is~$γⱼ$, then for all~$j≠i~$
\[
  \textsf{jump}(γⱼ) = \cc{Rest.}\textsf{jump}(γⱼ)
\]
In the special case of~$\textsf{jump}(γᵢ)$ the returned type is still~$\cc{Rest}$,
  this is due to the fact that before a \textsf{jump} operation,
  we do not pop an element from the stack.

All instantiations of~\cc{C} must make sure that actual parameters are properly constrained,
  to ensure that they are (the type version of) pointers into the actual stack,
  not a trivial task, as will be seen shortly.

In the running example,~\cc{C} is defined as:
\begin{quote}
  \javaInput[minipage,width=\ReplaceInThesis{61ex}{\linewidth},left=-2ex]{proof.configuration.listing}
\end{quote}
This excerpt shows also classes~\cc{E} and~\cc{¤} which encode (as in \cref{Figure:jump})
  the empty and the error configurations.

Type~\cc{C} defines~$ℓ+1$ functions (4 in the example), one for each possible input character,
  and one for the end-of-file character defined as \$.
Since~\cc{C} encodes an abstract configuration, return types of functions in it
  are the appropriate defaults which intentionally fail to emulate the automaton's execution.
  The return type of \cc{\$()} is \cc{ΣΣ} (rejection);
  the transition functions \cc{$σ$1()}, … \cc{$σ${}$ℓ$()}, return the raw type~\cc{C}.

\subsection{Top-of-Stack Types}

Types \cc{C$γ$1}, … ,\cc{C$γ${}$k$}, specializing~\cc{C},
  encode stacks whose top element is~$γ₁$, … ,$γₖ$.
In~$A$ there are two of these:
\begin{quote}
  \javaInput[minipage,width=\ReplaceInThesis{42ex}{\linewidth},left=-4ex]{proof.many.listing}
\end{quote}

In~$A$, types \cc{C$γ$1} and \cc{C$γ$2} take three parameters;
in general ‟Top of Stack" types take the aforementioned~$k+1$ parameters.

\ReplaceInThesis{\begin{wrapfigure}[14]r{45ex}
  \caption[Use examples of the type encoding of the jDPDA]{\label{Figure:chain} Accepting and non-accepting call chains with the
  type encoding of jDPDA~$A$ (as defined in \cref{Table:A}).
  All lines in \cc{accepts()} type-check, while all lines in \cc{rejects()} do not type-check.}
  \javaInput[minipage,left=-2ex,width=45ex]{proof.cases.listing}
\end{wrapfigure}
}{\begin{figure}[ht]
  \caption[Use examples of the type encoding of the jDPDA]{\label{Figure:chain} Accepting and non-accepting call chains with the
  type encoding of jDPDA~$A$ (as defined in \cref{Table:A}).
  All lines in \cc{accepts()} type-check, while all lines in \cc{rejects()} do not type-check.}
  \javaInput[minipage,left=-2ex,width=\linewidth]{proof.cases.listing}
\end{figure}
}
The method signatures of these types are generated using the mentioned parameters.
The generating of methods will be discussed next.

The code defines the \kk{static} variable \cc{build}, the starting point
of all fluent API call chains, to be of type \cc{C$γ$1<E,¤,¤>}, i.e.,
  the starting configuration of the automaton is a stack whose top is~$γ₁$,
  and its \cc{Rest} parameter is empty (\cc{E}).
Any of the two jumps possible on this rest results with,~\cc{¤},
  an undefined stack.
Examples of accepting and rejecting call chains starting at \cc{A.build}
  can be seen in \cref{Figure:chain}.

\subsection{Transitions}
It remains to show the type encoding of~$δ$,
  the transition function.
Overall, there are a total of~$k·(ℓ+1)$
  entries in a transition table such as \cref{Table:A}.
Conceptually, these are encoded by selecting the correct return
  type of functions \cc{$σ$1()}, … ,\cc{$σ${}$k$()} and \cc{\$()} in each
  of the~$k$ ‟Top of Stack” types.
Thanks to inheritance, we need to do so only in the cases that this
  return type is different from the default.

Overall, there are six kinds of entries in a transition table:
\begin{description}

  \item[\textsf{reject}]
  The default return type of \cc{\$()} in~\cc{C} is \cc{$ΣΣ$}, which
  is \emph{not} a subtype of~\cc{L}. Normally the result of a call chain that ends with \cc{\$()}
  cannot be assigned to a variable of type~\cc{L}. Moreover, since \cc{$ΣΣ$} is \kk{private},
  there is little that clients can do with this result.

  \item[\textsf{accept}]
  The only case in which fluent call chain ending with \cc{\$()} can return
    type~\cc{L} is when the type returned of the call just prior to~\cc{.\$()} covariantly
    changes the return type of~\cc{\$()} to~\cc{L}.†{This is not to be confused with dynamic binding;
    types of fluent API call chains are determined statically.}
  \par
  Recall that a jDPDA can only accept after its input is exhausted.
  In \cref{Table:A} we see that \textsf{accept} occurs when the top of the stack is~$γ₁$.
  We therefore add to the body of type \cc{C$γ$1} the line
  \begin{JAVA}
@Override L ¢\gobble$¢$();
  \end{JAVA}

  \item[$⊥$]
  When a prefix of the input is sufficient to conclude it must be rejected however it continues,
    the transition function returns~$⊥$.
  In~$A$ this occurs when the top of the stack is~$γ₁$ and one of~$σ_2$ or~$σ_3$ is read.
  To type encode~$δ(γ₁,σ₂) =⊥$, one must \emph{not} override \cc{$σ$2()} in type~\cc{C$γ$1};
    the inherited return type (l.15 \cref{Figure:A}) is the raw~\cc{C}.
  Subsequent calls in the chain will all receive and return a raw~\cc{C}
    (Recall that all \cc{$σ${}$i$()},~$i=1,…,ℓ$, are functions in~\cc{C} that return a raw~\cc{C}).
  Therefore, the final \cc{\$()} will reject.
  \par
  Two other situations in which a jDPDA rejects but not demonstrated in~$A$ are:
    a \textsf{jump} that encounters an empty stack, and reading a character from when the stack is empty.
  In our type encoding these are handled by the special
    types~\cc{E} and~\cc{¤} (ll.17--18 ibid), both extend~\cc{C} without
    overriding any of its methods. Again, remaining part of the call chain will stick to
    raw~\cc{C}s up until the final \cc{\$()} call rejects the input.

  \item[$\textsf{jump}(γᵢ)$]
  The design of the generic parameters makes the implementation of~$\textsf{jump}(γᵢ)$
    operations particularly simple.
  All that is required is to covariantly change the return type of the
    appropriate \cc{$σ${}$j$()} function to the appropriate \cc{JR$γ{}i$} or~\cc{Rest} parameter
    (recall that a jump occurs after popping the current element from the stack, so 
    we refer to \cc{JR} type parameters rather than~\cc{J}'s).
  \par
  In \cref{Table:A} we find that~$δ(γ₂,σ₃) =\textsf{jump}(γ₁)$. 
  Accordingly, the type of \cc{$σ$2()} in \cc{C$γ$2} (l.34) is \cc{JR$γ$1}.

  \item[$\textsf{push}(ζ)$]
  Push operations are the most complex, since they involve a pop of the top stack element,
    and pushing any number, including zero, of new elements.
  The challenge is in constructing the correct~$k+1$-parameter instantiation of~\cc{C},
    from the current parameters of the type.
  Each of these~$k+1$ is also an instantiation of~\cc{C} which may require more such
    parameters.
  Even though the number of ingredients is small, the resulting type expressions
    tend to be excessively long and unreadable.
  \par
  The predicament is ameliorated a bit by the idea,
    demonstrated above with auxiliary type~\cc{Pʹ}
    (\cref{Figure:jump-stack-push}),
    of delegating the task of creating a complex type to an auxiliary
    generic type.
  The task of this sidekick is simplified if some of its generic
  parameters are sub-expressions that recur in the desired
  result.
  \par
  Cases in point
    are~$δ(γ₁,σ₁)=\textsf{push}(γ₁,γ₁,γ₂)$, and~$δ(γ₂,σ₁)=\textsf{push}(γ₂,γ₂)$ of \cref{Table:A}.
  The corresponding sidekick types,
    (\cc{$γ$1$σ$1\_Push\_$γ$1$γ$1$γ$2} and \cc{$γ$2$σ$1\_Push\_$γ$2$γ$2})
    can be found in lines 36--43 of \cref{Figure:A}.
  The first of these define the correct return type
    of \cc{$σ$1()} in case \cc{$γ$1} is the top element,
    the second of \cc{$σ$2}, in case \cc{$γ$2} is the top element.
  Examine now the definition of types \cc{C$γ$1},\cc{C$γ$2} in the figure,
    and in particular lines 21--23 and 29--31 which define the list of types they extend.
  Notice that each extends one of the sidekicks, inheriting the covariant
    overrides of \cc{$σ$1()}.
  \par
  More generally, economy of expression may require that for each case
    of~$δ(γ,σ)=\textsf{push}(ζ)$ in the transition table,
    one creates a sidekick type which overrides the appropriate \cc{$σ$()}
    function.
  The appropriate \cc{C$γ$} type then inherits the definition
    from the sidekick.
\end{description}

\begin{figure}[htbp]
  \caption{\label{Figure:A}Type encoding of jDPDA~$A$ (as defined in \cref{Table:A})}
  \javaInput[minipage,listing style=numbered,width=1.08\columnwidth]{proof.full.listing}
\end{figure}

\paragraph*{Conclusion} The proof of~\Cref{Theorem:Gil-Levy} is an algorithm, taking as input some jDPDA,
  and returning as output a set of \Java type definitions.
The returned types, allow a call chain~$\textsf{java}(\alpha)$,
  such that the type of the returned object represents the 
  configuration of the input automaton after reading~$\alpha$.
If the automaton rejects after~$\alpha$, then the returned type is the illegal~$\Sigma\Sigma$, 
  and if the automaton accpets, the type shall be~$L$.
 
\section{The Prefix Theorem}
\label{section:prefix}
\begin{theorem}\label{Theorem:Gil-Levy:2}
  Let~$A$ be a DPDA recognizing a language~$L⊆Σ^*$.
  Then, there exists a \Java type definition,~$J_A$ for types~\cc{L},~\cc{A},~\cc{C} and
    other types such that the \Java command
  \begin{equation}
    \label{Equation:prefix:result}
    \cc{C c = A.build.$\textsf{java}(α)$;}
  \end{equation}
    type checks against~$J_A$ if an only if there exists~$β∈Σ^*$ such
    that~$αβ∈L$ and type \cc{C} is the configuration of~$A$ after reading~$α$.
  Furthermore, for any such~$β$,~\cref{Theorem:Gil-Levy} applies such that the
  \Java command
  \begin{equation}
    \cc{L~$ℓ$ = A.build.$\textsf{java}(αβ)$}\cc{.\$();}
  \end{equation}
    always type-checks.
  Finally, the program~$J_A$ can be effectively generated from~$A$.
\end{theorem}

Informally, a call chain type-checks if and only if it is a prefix
  of some legal sequence.
Alternatively, a call chain won't type-check if there is no
  continuation that leads to a legal string in~$L$.

The proof resembles~\cref{Theorem:Gil-Levy}'s proof.
We provide a similar implementation for a jump-stack
  †{recall that the two formal constructs are of the same expressiveness},
  that will not compile under illegal prefixes.

The main difference between the two theorems is:
  in~\cref{Theorem:Gil-Levy} we allowed illegal call chains to compile,
  but not return the required~\cc{L} type, while in~\cref{Theorem:Gil-Levy:2}
  the illegal chain won't compile at all.

Since the code suggested by the proof highly resembles the previously
  suggested code, mainly the differences will be discussed.

We will use the same running example, defined by~\cref{Table:A}.

\subsection{Main Types}
The main types here are a subset of the previously defined main types.

\begin{quote}
  \javaInput[minipage,width=\ReplaceInThesis{45ex}{\linewidth},left=-2ex]{prefix-proof.configuration.listing}
\end{quote}

First, type \cc{$ΣΣ$} is removed.
A call chain that doesn't represent a valid prefix won't compile,
  thus, there is no need for an error return type such as \cc{$\SigmaΣ$}.
Second, \kk{interface}~\cc{C} is removed.
Without it, the configuration types won't have the
  methods \cc{$σ$1()}, … ,\cc{$σ${}$k$()} and \cc{\$()} from the supertype.
These inherited methods, is what differentiates the previous proof from the current.
Classes \cc{¤} and \cc{E} are defined similarly, except now they don't extend any type.

\subsection{Top-of-Stack Types}
Types \cc{C$γ$1}, … ,\cc{C$γ${}$k$}, still represent stacks
  with \cc{$γ$1}, … ,\cc{$γ${}$k$} as their top element,
  this time, the methods are defined ad-hock, in each type
  (they are not added in this figure as they are added with the use of sidekicks).
In~$A$ there are two such types:

\begin{quote}
  \javaInput[minipage,width=\ReplaceInThesis{51ex}{\linewidth},left=-2ex]{prefix-proof.many.listing}
\end{quote}


Note, that the type parameters of the former types hasn't changed,
  since the model we are trying to implement, hasn't changed.
  These~$k+1$ parameters still suffice for our cause.

\ReplaceInThesis{\begin{wrapfigure}[13]r{42ex}
  \caption{\label{Figure:prefix-chain} Accepting and non-accepting call chains with the
  type encoding of jDPDA~$A$ (as defined in \cref{Table:A}).
  All lines in \cc{accepts} type-check, and all lines in \cc{rejects}
  cause type errors}
  \javaInput[minipage,width=42ex,left=-2ex]{prefix-proof.cases.listing}
\end{wrapfigure}
}{\begin{figure}[ht]
  \caption{\label{Figure:prefix-chain} Accepting and non-accepting call chains with the
  type encoding of jDPDA~$A$ (as defined in \cref{Table:A}).
  All lines in \cc{accepts} type-check, and all lines in \cc{rejects}
  cause type errors}
  \javaInput[minipage,width=\linewidth,left=-2ex]{prefix-proof.cases.listing}
\end{figure}
}
In~\cref{Figure:prefix-chain}, call chains in the~\cc{accepts()} method
  correctly type-checks (i.e., in~$L$), while the chains in~\cc{rejects()}
  do not type-check (i.e., these prefixes have no continuation that can lead to a legal word in~$L$),
  where the last method invocation generates an
\begin{quote}
  ‟\textsf{method~…~is undefined for the type~…~}”
\end{quote}
  error message.

The main difference between~\cref{Figure:prefix-chain} and~\cref{Figure:chain} is that there is no need to
  use an auxiliary function \cc{isL()} as in~\cref{Figure:prefix-chain} since now illegal
  prefixes do not type-check.

\subsection{Transitions}
Due to the changes we expressed, the transition table is encoded slightly different.

Encoding of the legal operations \textsf{accept},~$\textsf{jump}(γᵢ)$ and~$\textsf{push}(ζ)$
  remains as in~\cref{Theorem:Gil-Levy}, since we want the same behavior for legal call chains.
The minor differences are in the illegal operations \textsf{reject} and~$⊥$:

\begin{description}
 \item[\textsf{reject}] Since we add the methods ad-hock to each type, the reject entry means
   that the corresponding type, \emph{won't} have a~\cc{\$()} method, i.e., type~\cc{C$γ$2}
   doesn't have a method~\cc{\$()}.
 \item[$⊥$] We encounter~$⊥$ on the transition function when some input character~\cc{$σ$}
   is not allowed for the top of the stack element~$γ$. In that case, the corresponding type \cc{C$γ$}
   \emph{must not} have a method for~\cc{$σ$}, this way, invoking the methods will result in type error.
   In \cref{Table:A} a~$⊥$ may occur when the top of the stack is~$γ₁$ and the input character is~$σ₂$,
   thus, no method \cc{$σ$2} is introduced in type~\cc{C$γ$1}.
\end{description}

The use of sidekicks is still allowed and recommended to improve readability of code.

\begin{figure}[ht]
  \caption{\label{Figure:prefix-A}Type encoding of jDPDA~$A$ (as defined in \cref{Table:A})
    that allow a partial call chain, if and only if, there exists a legal continuation, that
    leads to a word in~$L$ (the language of~$A$)}
  \javaInput[minipage,listing style=numbered,width=1.08\textwidth]{prefix-proof.full.listing}
\end{figure}

\paragraph*{Conclusion}
In this section, a proof, similar to the one in~\cref{section:proof} is provided.
An algorithm was introduced, to not only emulate the running of some jDPDA~$A$,
  but also to ‟halt it” in the earliest time possible, i.e., only if there is
  no legal call chain from this point to result in a legal word in the language of~$A$.
 
\section{Notes on Practical Applicability}
\label{section:applicability}
\Cref{Theorem:Gil-Levy} and its proof above provide
  a concrete algorithm for converting an EBNF specification of a fluent API into
its realization:
\begin{quote}
  \begin{enumerate}
    \item Convert the specification into a plain BNF form
    \urlref{http://lampwww.epfl.ch/teaching/archive/compilation-ssc/2000/part4/parsing/node3.html}.
    \item Convert this BNF into a type of DPDA (using parsing algorithms e.g., LR(k), LALR\@, LL(k)). 
        This conversion might 
        fail~\footnote{In the LR case, we know\cite{Knuth:65} there exists an equivalent grammar for which the conversion will succeed}.
    \item Convert this DPDA into a jDPDA. (Conversion is guaranteed to succeed)
    \item Apply the proof to generate appropriate \Java type definitions, making sure to
        augment methods with code to maintain the fluent-call-list.
        Parsing the fluent-call-list can be done either in each method,
        or lazily, when the product of the fluent API call chain is to
        be used.
  \end{enumerate}
\end{quote}
Although possible, a practical tool that uses the proof directly 
  is a challenge. 
Part of the problem is the complexity of the 
  algorithms used, some of which, e.g., the DPDA and jDPDA equivalence have never been 
  implemented.
Yet another issue that clients of compiler-compiler have grown to expect 
  facilities such as means for resolving ambiguities, manipulation 
  of attributes, etc.
Also, for a fluent API to be elegant and useful, 
  it should support method with parameters whose parameters are also defined by a  fluent API:
these two APIs may mutually recursive and even the same. 
Support of these features through four or so algorithmic abstractions 
  may turn out to be a decent engineering task.

\begin{figure}[H]
  \caption{\label{Figure:compiler} Exponential compilation time for a simple \Java program.
  }
  \begin{minipage}{\textwidth}
  \begin{tabular}{@{}c@{}c@{}}
    \hspace{3ex}\parbox[c]{44ex}{\javaInput[minipage,width=40ex,]{compiler.listing}} &
    \hspace{0ex} \parbox[c]{44ex}{\gnuplotloadfile[terminal=pdf,terminaloptions={crop size 2.5in,1.5in color enhanced font ",8" linewidth 1}]{kill.gnuplot}}⏎
      \textbf{(a)} Encoding of a binary type tree 
    & 
      \textbf{(b)} Compilation time 
      (sec†{\scriptsize{measured on an Intel i5-2520M CPU @ 2.50GHz~$⨉$4, 3.7GB memory, Ubuntu 15.04 64-bit, \texttt{javac} 1.8.0\_66}})    \\ &
     \emph{vs.}
      length of call chain.
  \end{tabular}
  \end{minipage}
\end{figure}


Yet another challenge is controlling the compiler's  
  runtime.
Learning that linear time parsers and lexical analyzers are possible, 
  and being accustomed to seeing these in practice, one 
  may expect the compiler would run in linear, or at least polynomial time. 
As it turns out, this time is exponential in the worst case (at least for \texttt{javac}).
An encoding of a S-expression in type~\cc{Cons} (\cref{Figure:compiler}(a)) 
  is a not terribly complex such worst case.
  
Type \cc{Cons} takes two type parameters, \cc{Car} and \cc{Cdr} (denoting left and right branches).
Denote the return type of \cc{d()} by 
\[
  τ= \cc{Cons< Cons<Car, Cdr>, Cons<Car, Cdr> >}.
\]
Let~$σ$ denote the type of the \kk{this} implicit parameter to~\cc{d}.
Now, since~$τ= \cc{Cons<}σ,σ\cc{>}$, we have~$|τ|≥2|σ|$,
  where the size of a type is measured, e.g., in number of characters in its textual representation.
Therefore, in a chain of~$n$ calls to \cc{d()}
\begin{equation}
  \label{Equation:n}
  \cc{(Cons<?,?>(null)).}\overbrace{\cc{d().}⋯\cc{.d()}}^{\text{$n$ times}}\cc{;}
\end{equation}
the size of the resulting type is~$O(2ⁿ)$.


\Cref{Figure:compiler}(b) shows, on the doubly logarithmic plane, the runtime
(on a Lenovo X220) of the \texttt{javac} compiler (version 1.8.0\_66) in face
of a \Java program assembled from \cref{Figure:compiler} and \cref{Equation:n}
placed as the single command of \cc{main()}.  Exponential growth is
demonstrated by the right-hand side of the plot, in which curve converges on a
straight line.  (In fact, a variation of the construction may lead to even
super-exponential growth rate of the size of types.)

We believe that this exponential growth is due to a design flaw in the
compiler.  Had the compiler used a representation of types that allows sharing
of expression types, compilation time would be linear. 

Still, with current compiler technology, the type encoding scheme demonstrated
in \cref{Figure:A} might not be scalable.
 
\section{Conclusion and Future Work}
\label{section:zz}
The main contribution of this work is the proof that
  most useful grammars have a fluent API\@.
This brings good news to library designers laboring
  at making their API slick, accessible, and more
  robust to mistakes of clients:
If your API can be phrased in terms of a ‟decent”
  BNF, do not lose hope; the task may be Herculean, but it is (most likely) possible.

Other practitioners may appreciate the toolbox of type encodings offered here
  gaining better understanding of the computational expressiveness of
  \Java generics and type hierarchy, and, a better tool
  for designing, experimenting with and perfecting fluent APIs.

However, once possibility was demonstrated theoretically, the next \emph{research}
    challenge is in an actual fluent API compiler based on lighter weight
  parsing algorithms.
Precisely, the challenge
  is in developing a parsing (or at least recognition)
  algorithm which is not only efficient but also falls within the limited computing power of the \Java types.

On the theoretical front, one may ask whether
  our result is the best possible:
Can the \Java type system be coerced to recognize
  general (that is, nondeterministic) context-free languages?

As mentioned earlier, to the best of our knowledge,
  the complexity of the \Java type checker has never been analyzed.
In light of the empirical finding in \cref{section:applicability},
  research in this direction may be worthwhile.

Other directions include
  formalizing the proof in \cref{section:proof} here and
  extensions to other languages.

On a philosophical perspective, several modern programming languages
  acquire high-level constructs at a staggering rate
  (\CC and \Scala being prominent examples).
The main yardstick for evaluation these
  is ‟programmer's convenience”.
This work suggests an orthogonal perspective, namely
  computational expressiveness, or, stated differently,
    ranking of a new construct by its ability to recognize languages
    in the Chomsky hierarchy~\cite{Chomsky:1963}.
 
\small
\bibliography{gil}

\end{document}
